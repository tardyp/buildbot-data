{"version":3,"sources":["data.module.coffee","scripts.js","data.config.coffee","data.constant.coffee","specification.constant.coffee","mock/generator.service.coffee","services/data/data.service.coffee","services/data/dbstores.constant.coffee","services/dataUtils/dataUtils.service.coffee","services/indexeddb/indexeddb.service.coffee","services/rest/rest.service.coffee","services/socket/socket.service.coffee","services/socket/webSocketBackend.service.coffee","services/tabex/tabex.service.coffee","services/data/collection/collection.service.coffee","services/data/wrapper/wrapper.service.coffee"],"names":["App","angular","module","call","this","HttpConfig","$httpProvider","useApplyAsync","interceptors","push","$log","API","request","config","url","indexOf","debug","method","Api","constant","Specification","FIELDTYPES","IDENTIFIER","NUMBER","builds","id","fields","root","paths","static","complete","builders","identifier","buildrequests","buildsets","buildslaves","changes","changesources","forceschedulers","masters","schedulers","sourcestamps","steps","logs","contents","restField","properties","Generator","slice","self","prototype","number","min","max","random","Math","floor","ids","name","base","timestamp","after","date","Date","now","getTime","string","length","Number","MAX_VALUE","toString","substring","array","args","fn","i","j","ref","times","arguments","apply","service","Data","cache","$get","$injector","$q","$window","Collection","restService","dataUtilsService","tabexService","indexedDBService","SPECIFICATION","DataService","endpoints","extend","Object","keys","filter","e","constructor","generateEndpoints","clearCache","clear","then","has","get","reload","location","collection","query","restPath","processArguments","subscribe","createCollection","mocks","spied","when","returnValue","jasmine","spyOn","and","callFake","_mockGet","p","queryWithoutSubscribe","ref1","ref2","copy","Error","toJson","from","resolve","getArray","func","ctor","child","result","last","isObject","pop","control","params","jsonrpc","post","forEach","_this","E","capitalize","concat","open","scope","DataAccessor","collections","closeOnDestroy","close","c","unsubscribe","isFunction","$on","$inject","provider","DBStores","DataUtils","toUpperCase","toLowerCase","type","arg","a","copyOrSplit","singularType","replace","socketPath","stars","join","endpointPath","arrayOrString","isArray","isString","split","TypeError","unWrap","data","path","parse","object","error","error1","k","v","fromJson","numberOrString","str","isNumber","parseInt","isNaN","emailInString","emailRegex","exec","IndexedDB","item","l","DBSTORES","IndexedDBService","stores","db","Dexie","processSpecification","version","on","reject","processUrl","q","table","tableName","transaction","toArray","fieldAndOperator","filters","limit","offset","order","property","value","map","sort","paginate","field","cmp","operator","compare","reverse","b","f","len","o","end","element","key","fieldName","fieldType","fieldValue","match","nextUrl","parentFieldName","parentFieldValue","parentId","parentName","pathString","ref3","specification","splitted","replaced","RegExp","test","s","unshift","Rest","$http","RestService","execute","success","response","reason","headers","Accept","Content-Type","Socket","$location","webSocketBackendService","SocketService","queue","deferred","onMessage","onClose","socket","getWebSocket","onopen","flush","onmessage","message","code","_id","msg","m","onclose","send","nextId","defer","readyState","OPEN","promise","results","shift","getRootPath","pathname","getUrl","defaultport","host","port","protocol","ReconnectingWebSocket","WebSocket","WebSocketBackend","webSocket","MockWebSocket","sendQueue","receiveQueue","Tabex","bind","me","$timeout","socketService","TabexService","closeHandler","messageHandler","refreshHandler","masterHandler","initialRoleDeferred","initialRole","client","CHANNELS","MASTER","REFRESH","onunload","onbeforeunload","activatePaths","EVENTS","ROLES","SLAVE","_ROLES","READY","UPDATE","NEW","tabex","getSpecification","node_id","master_id","role","masterRefreshHandler","debounceTimeout","trackedPaths","consuming","timeoutPromise","cancel","channel","channels","name1","r","startConsumingAll","stopConsuming","loadAll","event","put","results1","emit","dbPaths","queries","load","active","dbPath","elapsed","inCache","parentIdName","t","equals","lastActive","getParent","idName","where","modify","listener","options","off","startConsuming","cmd","len1","len2","len3","n","pathsToRemove","promises","socketPaths","splice","all","mergePaths","dest","src","parent","hasProp","__super__","hasOwnProperty","CollectionInstance","superClass","Wrapper","ready","getRestPath","getQuery","getSocketPath","getType","getEndpoint","getWrapper","getReadyDeferred","getReadyPromise","readyHandler","updateHandler","newHandler","new","old","add","update","instance","index","Array","factory","dataService","WrapperInstance","endpoint","_subscribe","_endpoint","generateFunctions","merge","parameter","getId","getIdentifier","base1","classId","classIdentifier","_"],"mappings":"CACA,WAAA,GAAAA,EAAMA,GAAA,WACW,QAAAA,KACT,SCKJ,MAAOA,MDFXC,QAAQC,OAAO,SAAc,GAAAF,MCQ1BG,KAAKC,MCdR,WAAA,GAAAC,EAAMA,GAAA,WACW,QAAAA,GAACC,GAIVA,EAAcC,eAAc,GAE5BD,EAAcE,aAAaC,MAAA,OAAA,MAAK,SAACC,EAAMC,GACnC,OAAOC,QAAS,SAACC,GAIb,MAF8B,KAA3BA,EAAOC,IAAIC,QAAQJ,IAClBD,EAAKM,MAASH,EAAOI,OAAO,IAAGJ,EAAOC,KACnCD,ODwBnB,MAAOR,MCrBXJ,QAAQC,OAAO,UACdW,QAAQ,gBAAiBR,KD0BvBF,KAAKC,ME1CR,WAAA,GAAAc,EAAMA,GAAA,WACW,QAAAA,KAAG,MAAO,UFmDvB,MAAOA,MEhDXjB,QAAQC,OAAO,UACdiB,SAAS,MAAOD,MFqDdf,KAAKC,MGvDR,WAAA,GAAAgB,EAAMA,GAAA,WACW,QAAAA,KACT,OACIC,YACIC,WAAY,IACZC,OAAQ,KAEZC,QACIC,GAAI,UACJC,QACI,UACA,YACA,iBACA,eACA,WACA,cACA,WACA,SACA,UACA,aACA,gBAEJC,MAAM,EACNC,OACI,UACA,aACA,QACA,eACA,oBACA,2BACA,oCACA,+BACA,iBACA,sBACA,6BACA,sCACA,kCAEJC,UACIC,UAAU,IAClBC,UACIN,GAAI,YACJO,WAAY,OACZN,QACI,YACA,cACA,OACA,QAEJC,MAAM,EACNC,OACI,kBACA,gBACA,UACA,qBACA,cACA,qBACA,6BACA,SACA,kBACA,wBACA,+BACA,oCACA,2CACA,oDACA,+CACA,iCACA,sCACA,6CACA,sDACA,kDAEJC,UAAQ,GACZI,eACIR,GAAI,iBACJC,QACI,iBACA,YACA,aACA,UACA,aACA,sBACA,WACA,cACA,WACA,UACA,eACA,cAEJC,MAAM,EACNC,OACI,UAEJC,UACIC,UAAU,IAClBI,WACIT,GAAI,OACJC,QACI,OACA,WACA,cACA,oBACA,iBACA,sBACA,SACA,UACA,eACA,gBAEJC,MAAM,EACNC,OACI,cAEJC,UACIC,UAAU,IAClBK,aACIV,GAAI,eACJC,QACI,eACA,gBACA,eACA,OACA,aAEJC,MAAM,EACNC,SACAC,UAAQ,GACZO,SACIX,GAAI,WACJC,QACI,WACA,SACA,SACA,WACA,WACA,WACA,QACA,mBACA,UACA,aACA,aACA,WACA,UACA,cACA,kBAEJC,MAAM,EACNC,SACAC,UAAQ,GACZQ,eACIZ,GAAI,iBACJC,QACI,iBACA,SACA,QAEJC,MAAM,EACNC,SACAC,UAAQ,GACZS,iBACIb,GAAI,OACJC,QACI,OACA,aACA,gBACA,SAEJC,MAAM,EACNC,SACAC,UAAQ,GACZU,SACId,GAAI,WACJC,QACI,WACA,SACA,cACA,QAEJC,MAAM,EACNC,OACI,WACA,uBACA,mCACA,kDACA,0CACA,cACA,qBACA,6BACA,gBACA,iCACA,aACA,4BAEJC,UAAQ,GACZW,YACIf,GAAI,cACJC,QACI,cACA,SACA,QAEJC,MAAM,EACNC,SACAC,UAAQ,GACZY,cACIhB,GAAI,OACJC,QACI,OACA,SACA,WACA,aACA,QACA,UACA,aACA,YAEJC,MAAM,EACNC,OACI,WAEJC,UAAQ,GAEZa,OACIjB,GAAI,SACJO,WAAY,OACZN,QACI,SACA,UACA,WACA,cACA,SACA,OACA,SACA,UACA,aACA,eACA,QAEJC,MAAM,EACNC,OACI,OACA,cACA,uBACA,mBAEJC,UACIC,UAAU,IAClBa,MACIlB,GAAI,QACJO,WAAY,OACZN,QACI,QACA,WACA,OACA,YACA,OACA,SACA,QAEJC,MAAM,EACNC,OACI,WACA,OAEJC,UACIC,UAAU,IAClBc,UACInB,GAAI,KACJC,QACI,QACA,YACA,aAEJC,MAAM,EACNkB,UAAW,aACfC,YACIrB,GAAI,KACJC,UACAC,MAAM,IH7FlB,MAAOP,MGiGXnB,QAAQC,OAAO,UACdiB,SAAS,gBAAiBC,MH5FxBjB,KAAKC,MIjMR,WAAA,GAAA2C,GAAAC,KAAAA,KAAMD,GAAA,WAEW,QAAAA,KACTE,EAAO7C,KAFX,GAAA6C,EJuQA,OIvQAA,GAAO,KJ+MPF,EAAUG,UI3MVC,OAAQ,SAACC,EAASC,GAC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","file":"scripts.js","sourcesContent":["# Register new module\nclass App extends App\n    constructor: ->\n        return []\n","(function() {\n  var App;\n\n  App = (function() {\n    function App() {\n      return [];\n    }\n\n    return App;\n\n  })();\n\n  angular.module('bbData', new App());\n\n}).call(this);\n\n(function() {\n  var HttpConfig;\n\n  HttpConfig = (function() {\n    function HttpConfig($httpProvider) {\n      $httpProvider.useApplyAsync(true);\n\n      /* @ngInject */\n      $httpProvider.interceptors.push(function($log, API) {\n        return {\n          request: function(config) {\n            if (config.url.indexOf(API) === 0) {\n              $log.debug(config.method + \" \" + config.url);\n            }\n            return config;\n          }\n        };\n      });\n    }\n\n    return HttpConfig;\n\n  })();\n\n  angular.module('bbData').config(['$httpProvider', HttpConfig]);\n\n}).call(this);\n\n(function() {\n  var Api;\n\n  Api = (function() {\n    function Api() {\n      return 'api/v2/';\n    }\n\n    return Api;\n\n  })();\n\n  angular.module('bbData').constant('API', Api());\n\n}).call(this);\n\n(function() {\n  var Specification;\n\n  Specification = (function() {\n    function Specification() {\n      return {\n        FIELDTYPES: {\n          IDENTIFIER: 'i',\n          NUMBER: 'n'\n        },\n        builds: {\n          id: 'buildid',\n          fields: ['buildid', 'builderid', 'buildrequestid', 'buildslaveid', 'complete', 'complete_at', 'masterid', 'number', 'results', 'started_at', 'state_string'],\n          root: true,\n          paths: ['changes', 'properties', 'steps', 'steps/i:name', 'steps/i:name/logs', 'steps/i:name/logs/i:slug', 'steps/i:name/logs/i:slug/contents', 'steps/i:name/logs/i:slug/raw', 'steps/n:number', 'steps/n:number/logs', 'steps/n:number/logs/i:slug', 'steps/n:number/logs/i:slug/contents', 'steps/n:number/logs/i:slug/raw'],\n          \"static\": {\n            complete: true\n          }\n        },\n        builders: {\n          id: 'builderid',\n          identifier: 'name',\n          fields: ['builderid', 'description', 'name', 'tags'],\n          root: true,\n          paths: ['forceschedulers', 'buildrequests', 'masters', 'masters/n:masterid', 'buildslaves', 'buildslaves/i:name', 'buildslaves/n:buildslaveid', 'builds', 'builds/n:number', 'builds/n:number/steps', 'builds/n:number/steps/i:name', 'builds/n:number/steps/i:name/logs', 'builds/n:number/steps/i:name/logs/i:slug', 'builds/n:number/steps/i:name/logs/i:slug/contents', 'builds/n:number/steps/i:name/logs/i:slug/raw', 'builds/n:number/steps/n:number', 'builds/n:number/steps/n:number/logs', 'builds/n:number/steps/n:number/logs/i:slug', 'builds/n:number/steps/n:number/logs/i:slug/contents', 'builds/n:number/steps/n:number/logs/i:slug/raw'],\n          \"static\": true\n        },\n        buildrequests: {\n          id: 'buildrequestid',\n          fields: ['buildrequestid', 'builderid', 'buildsetid', 'claimed', 'claimed_at', 'claimed_by_masterid', 'complete', 'complete_at', 'priority', 'results', 'submitted_at', 'waited_for'],\n          root: true,\n          paths: ['builds'],\n          \"static\": {\n            complete: true\n          }\n        },\n        buildsets: {\n          id: 'bsid',\n          fields: ['bsid', 'complete', 'complete_at', 'external_idstring', 'parent_buildid', 'parent_relationship', 'reason', 'results', 'sourcestamps', 'submitted_at'],\n          root: true,\n          paths: ['properties'],\n          \"static\": {\n            complete: true\n          }\n        },\n        buildslaves: {\n          id: 'buildslaveid',\n          fields: ['buildslaveid', 'configured_on', 'connected_to', 'name', 'slaveinfo'],\n          root: true,\n          paths: [],\n          \"static\": true\n        },\n        changes: {\n          id: 'changeid',\n          fields: ['changeid', 'author', 'branch', 'category', 'codebase', 'comments', 'files', 'parent_changeids', 'project', 'properties', 'repository', 'revision', 'revlink', 'sourcestamp', 'when_timestamp'],\n          root: true,\n          paths: [],\n          \"static\": true\n        },\n        changesources: {\n          id: 'changesourceid',\n          fields: ['changesourceid', 'master', 'name'],\n          root: true,\n          paths: [],\n          \"static\": true\n        },\n        forceschedulers: {\n          id: 'name',\n          fields: ['name', 'all_fields', 'builder_names', 'label'],\n          root: true,\n          paths: [],\n          \"static\": true\n        },\n        masters: {\n          id: 'masterid',\n          fields: ['masterid', 'active', 'last_active', 'name'],\n          root: true,\n          paths: ['builders', 'builders/n:builderid', 'builders/n:builderid/buildslaves', 'builders/n:builderid/buildslaves/n:buildslaveid', 'builders/n:builderid/buildslaves/i:name', 'buildslaves', 'buildslaves/i:name', 'buildslaves/n:buildslaveid', 'changesources', 'changesources/n:changesourceid', 'schedulers', 'schedulers/n:schedulerid'],\n          \"static\": true\n        },\n        schedulers: {\n          id: 'schedulerid',\n          fields: ['schedulerid', 'master', 'name'],\n          root: true,\n          paths: [],\n          \"static\": true\n        },\n        sourcestamps: {\n          id: 'ssid',\n          fields: ['ssid', 'branch', 'codebase', 'created_at', 'patch', 'project', 'repository', 'revision'],\n          root: true,\n          paths: ['changes'],\n          \"static\": true\n        },\n        steps: {\n          id: 'stepid',\n          identifier: 'name',\n          fields: ['stepid', 'buildid', 'complete', 'complete_at', 'hidden', 'name', 'number', 'results', 'started_at', 'state_string', 'urls'],\n          root: false,\n          paths: ['logs', 'logs/i:slug', 'logs/i:slug/contents', 'logs/i:slug/raw'],\n          \"static\": {\n            complete: true\n          }\n        },\n        logs: {\n          id: 'logid',\n          identifier: 'slug',\n          fields: ['logid', 'complete', 'name', 'num_lines', 'slug', 'stepid', 'type'],\n          root: false,\n          paths: ['contents', 'raw'],\n          \"static\": {\n            complete: true\n          }\n        },\n        contents: {\n          id: null,\n          fields: ['logid', 'logchunks', 'firstline'],\n          root: false,\n          restField: 'logchunks'\n        },\n        properties: {\n          id: null,\n          fields: [],\n          root: false\n        }\n      };\n    }\n\n    return Specification;\n\n  })();\n\n  angular.module('bbData').constant('SPECIFICATION', Specification());\n\n}).call(this);\n\n(function() {\n  var Generator,\n    slice = [].slice;\n\n  Generator = (function() {\n    var self;\n\n    self = null;\n\n    function Generator() {\n      self = this;\n    }\n\n    Generator.prototype.number = function(min, max) {\n      var random;\n      if (min == null) {\n        min = 0;\n      }\n      if (max == null) {\n        max = 100;\n      }\n      random = Math.random() * (max - min) + min;\n      return Math.floor(random);\n    };\n\n    Generator.prototype.ids = {};\n\n    Generator.prototype.id = function(name) {\n      var base;\n      if (name == null) {\n        name = '';\n      }\n      if ((base = self.ids)[name] == null) {\n        base[name] = 0;\n      }\n      return self.ids[name]++;\n    };\n\n    Generator.prototype.boolean = function() {\n      return Math.random() < 0.5;\n    };\n\n    Generator.prototype.timestamp = function(after) {\n      var date;\n      if (after == null) {\n        after = Date.now();\n      }\n      date = new Date(after + self.number(1, 1000000));\n      return Math.floor(date.getTime() / 1000);\n    };\n\n    Generator.prototype.string = function(length) {\n      if (length != null) {\n        length++;\n      }\n      return self.number(100, Number.MAX_VALUE).toString(36).substring(0, length);\n    };\n\n    Generator.prototype.array = function() {\n      var args, array, fn, i, j, ref, times;\n      fn = arguments[0], args = 2 <= arguments.length ? slice.call(arguments, 1) : [];\n      times = self.number(1, 10);\n      array = [];\n      for (i = j = 1, ref = times; 1 <= ref ? j <= ref : j >= ref; i = 1 <= ref ? ++j : --j) {\n        array.push(fn.apply(null, args));\n      }\n      return array;\n    };\n\n    return Generator;\n\n  })();\n\n  angular.module('bbData').service('generatorService', [Generator]);\n\n}).call(this);\n\n(function() {\n  var Data,\n    slice = [].slice;\n\n  Data = (function() {\n    var config;\n\n    Data.prototype.cache = true;\n\n    config = null;\n\n    function Data() {\n      config = {\n        cache: this.cache\n      };\n    }\n\n\n    /* @ngInject */\n\n    Data.prototype.$get = function($log, $injector, $q, $window, Collection, restService, dataUtilsService, tabexService, indexedDBService, SPECIFICATION) {\n      var DataService;\n      return new (DataService = (function() {\n        var self;\n\n        self = null;\n\n        function DataService() {\n          var endpoints;\n          self = this;\n          angular.extend(this, config);\n          endpoints = Object.keys(SPECIFICATION).filter(function(e) {\n            return SPECIFICATION[e].id != null;\n          });\n          this.constructor.generateEndpoints(endpoints);\n        }\n\n        DataService.prototype.clearCache = function() {\n          return indexedDBService.clear().then(function() {\n            if ($injector.has('$state')) {\n              return $injector.get('$state').reload();\n            } else if ($injector.has('$route')) {\n              return $injector.get('$route').reload();\n            } else {\n              return $window.location.reload();\n            }\n          });\n        };\n\n        DataService.prototype.get = function() {\n          var args, collection, query, ref, restPath;\n          args = 1 <= arguments.length ? slice.call(arguments, 0) : [];\n          ref = this.processArguments(args), restPath = ref[0], query = ref[1];\n          if (query.subscribe == null) {\n            query.subscribe = false;\n          }\n          collection = this.createCollection(restPath, query);\n          return collection.subscribe();\n        };\n\n        DataService.prototype.mocks = {};\n\n        DataService.prototype.spied = false;\n\n        DataService.prototype.when = function() {\n          var args, base, query, ref, returnValue, url;\n          args = 1 <= arguments.length ? slice.call(arguments, 0) : [];\n          url = args[0], query = args[1], returnValue = args[2];\n          if (returnValue == null) {\n            ref = [{}, query], query = ref[0], returnValue = ref[1];\n          }\n          if ((typeof jasmine !== \"undefined\" && jasmine !== null) && !this.spied) {\n            spyOn(this, 'get').and.callFake(this._mockGet);\n            this.spied = true;\n          }\n          if ((base = this.mocks)[url] == null) {\n            base[url] = {};\n          }\n          return this.mocks[url][query] = returnValue;\n        };\n\n        DataService.prototype._mockGet = function() {\n          var args, collection, p, query, queryWithoutSubscribe, ref, ref1, ref2, returnValue, url;\n          args = 1 <= arguments.length ? slice.call(arguments, 0) : [];\n          ref = this.processArguments(args), url = ref[0], query = ref[1];\n          queryWithoutSubscribe = angular.copy(query);\n          delete queryWithoutSubscribe.subscribe;\n          returnValue = ((ref1 = this.mocks[url]) != null ? ref1[query] : void 0) || ((ref2 = this.mocks[url]) != null ? ref2[queryWithoutSubscribe] : void 0);\n          if (returnValue == null) {\n            throw new Error(\"No return value for: \" + url + \" (\" + (angular.toJson(query)) + \")\");\n          }\n          collection = this.createCollection(url, query);\n          collection.from(returnValue);\n          p = $q.resolve(collection);\n          p.getArray = function() {\n            return collection;\n          };\n          return p;\n        };\n\n        DataService.prototype.createCollection = function() {\n          var args;\n          args = 1 <= arguments.length ? slice.call(arguments, 0) : [];\n          return (function(func, args, ctor) {\n            ctor.prototype = func.prototype;\n            var child = new ctor, result = func.apply(child, args);\n            return Object(result) === result ? result : child;\n          })(Collection, args, function(){});\n        };\n\n        DataService.prototype.processArguments = function(args) {\n          var last, query, restPath;\n          args.filter(function(e) {\n            return e != null;\n          });\n          last = args[args.length - 1];\n          if (angular.isObject(last)) {\n            query = args.pop();\n          }\n          restPath = dataUtilsService.restPath(args);\n          return [restPath, query || {}];\n        };\n\n        DataService.prototype.control = function(url, method, params) {\n          if (params == null) {\n            params = {};\n          }\n          if (this.jsonrpc == null) {\n            this.jsonrpc = 1;\n          }\n          return restService.post(url, {\n            id: this.jsonrpc++,\n            jsonrpc: '2.0',\n            method: method,\n            params: params\n          });\n        };\n\n        DataService.generateEndpoints = function(endpoints) {\n          return endpoints.forEach((function(_this) {\n            return function(e) {\n              var E;\n              E = dataUtilsService.capitalize(e);\n              return _this.prototype[\"get\" + E] = function() {\n                var args;\n                args = 1 <= arguments.length ? slice.call(arguments, 0) : [];\n                return self.get.apply(self, [e].concat(slice.call(args)));\n              };\n            };\n          })(this));\n        };\n\n        DataService.prototype.open = function(scope) {\n          var DataAccessor;\n          return new (DataAccessor = (function() {\n            var collections;\n\n            collections = [];\n\n            function DataAccessor() {\n              var endpoints;\n              this.collections = collections;\n              endpoints = Object.keys(SPECIFICATION).filter(function(e) {\n                return SPECIFICATION[e].id != null;\n              });\n              this.constructor.generateEndpoints(endpoints);\n              if (scope != null) {\n                this.closeOnDestroy(scope);\n              }\n            }\n\n            DataAccessor.prototype.close = function() {\n              return collections.forEach(function(c) {\n                return typeof c.unsubscribe === \"function\" ? c.unsubscribe() : void 0;\n              });\n            };\n\n            DataAccessor.prototype.closeOnDestroy = function(scope) {\n              if (!angular.isFunction(scope.$on)) {\n                throw new Error(\"Parameter 'scope' doesn't have an $on function\");\n              }\n              return scope.$on('$destroy', (function(_this) {\n                return function() {\n                  return _this.close();\n                };\n              })(this));\n            };\n\n            DataAccessor.generateEndpoints = function(endpoints) {\n              return endpoints.forEach((function(_this) {\n                return function(e) {\n                  var E;\n                  E = dataUtilsService.capitalize(e);\n                  return _this.prototype[\"get\" + E] = function() {\n                    var args, last, p;\n                    args = 1 <= arguments.length ? slice.call(arguments, 0) : [];\n                    last = args[args.length - 1];\n                    if (angular.isObject(last)) {\n                      if (last.subscribe == null) {\n                        last.subscribe = true;\n                      }\n                    } else {\n                      args.push({\n                        subscribe: true\n                      });\n                    }\n                    p = self[\"get\" + E].apply(self, args);\n                    collections.push(p.getArray());\n                    return p;\n                  };\n                };\n              })(this));\n            };\n\n            return DataAccessor;\n\n          })());\n        };\n\n        return DataService;\n\n      })());\n    };\n\n    return Data;\n\n  })();\n\n  angular.module('bbData').provider('dataService', [Data]);\n\n}).call(this);\n\n(function() {\n  var DBStores;\n\n  DBStores = (function() {\n    function DBStores() {\n      return {\n        paths: '&[path+query],path,query,lastActive'\n      };\n    }\n\n    return DBStores;\n\n  })();\n\n  angular.module('bbData').constant('DBSTORES', DBStores());\n\n}).call(this);\n\n(function() {\n  var DataUtils;\n\n  DataUtils = (function() {\n    function DataUtils(SPECIFICATION) {\n      var dataUtilsService;\n      return new (dataUtilsService = (function() {\n        function dataUtilsService() {}\n\n        dataUtilsService.prototype.capitalize = function(string) {\n          return string[0].toUpperCase() + string.slice(1).toLowerCase();\n        };\n\n        dataUtilsService.prototype.type = function(arg) {\n          var a;\n          a = this.copyOrSplit(arg);\n          a = a.filter(function(e) {\n            return e !== '*';\n          });\n          if (a.length % 2 === 0) {\n            a.pop();\n          }\n          return a.pop();\n        };\n\n        dataUtilsService.prototype.singularType = function(arg) {\n          return this.type(arg).replace(/s$/, '');\n        };\n\n        dataUtilsService.prototype.socketPath = function(arg) {\n          var a, stars;\n          a = this.copyOrSplit(arg);\n          stars = ['*'];\n          if (a.length % 2 === 1) {\n            stars.push('*');\n          }\n          return a.concat(stars).join('/');\n        };\n\n        dataUtilsService.prototype.restPath = function(arg) {\n          var a;\n          a = this.copyOrSplit(arg);\n          a = a.filter(function(e) {\n            return e !== '*';\n          });\n          return a.join('/');\n        };\n\n        dataUtilsService.prototype.endpointPath = function(arg) {\n          var a;\n          a = this.copyOrSplit(arg);\n          a = a.filter(function(e) {\n            return e !== '*';\n          });\n          if (a.length % 2 === 0) {\n            a.pop();\n          }\n          return a.join('/');\n        };\n\n        dataUtilsService.prototype.copyOrSplit = function(arrayOrString) {\n          if (angular.isArray(arrayOrString)) {\n            return arrayOrString.slice(0);\n          } else if (angular.isString(arrayOrString)) {\n            return arrayOrString.split('/');\n          } else {\n            throw new TypeError(\"Parameter 'arrayOrString' must be a array or a string, not \" + (typeof arrayOrString));\n          }\n        };\n\n        dataUtilsService.prototype.unWrap = function(data, path) {\n          var ref, type;\n          type = this.type(path);\n          type = ((ref = SPECIFICATION[type]) != null ? ref.restField : void 0) || type;\n          return data[type];\n        };\n\n        dataUtilsService.prototype.parse = function(object) {\n          var error, error1, k, v;\n          for (k in object) {\n            v = object[k];\n            try {\n              object[k] = angular.fromJson(v);\n            } catch (error1) {\n              error = error1;\n            }\n          }\n          return object;\n        };\n\n        dataUtilsService.prototype.numberOrString = function(str) {\n          var number;\n          if (str == null) {\n            str = null;\n          }\n          if (angular.isNumber(str)) {\n            return str;\n          }\n          number = parseInt(str, 10);\n          if (!isNaN(number)) {\n            return number;\n          } else {\n            return str;\n          }\n        };\n\n        dataUtilsService.prototype.emailInString = function(string) {\n          var emailRegex;\n          if (!angular.isString(string)) {\n            throw new TypeError(\"Parameter 'string' must be a string, not \" + (typeof string));\n          }\n          emailRegex = /[a-zA-Z0-9.!#$%&'*+\\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*/;\n          return emailRegex.exec(string).pop() || '';\n        };\n\n        return dataUtilsService;\n\n      })());\n    }\n\n    return DataUtils;\n\n  })();\n\n  angular.module('bbData').service('dataUtilsService', ['SPECIFICATION', DataUtils]);\n\n}).call(this);\n\n(function() {\n  var IndexedDB,\n    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },\n    slice = [].slice;\n\n  IndexedDB = (function() {\n    function IndexedDB($log, $injector, $q, $window, dataUtilsService, DBSTORES, SPECIFICATION) {\n      var IndexedDBService;\n      return new (IndexedDBService = (function() {\n        function IndexedDBService() {\n          var stores;\n          this.db = new $window.Dexie('BBCache');\n          stores = {};\n          angular.extend(stores, this.processSpecification(SPECIFICATION), DBSTORES);\n          this.db.version(1).stores(stores);\n          this.db.on('error', function(e) {\n            return $log.error(e);\n          });\n          this.open();\n        }\n\n        IndexedDBService.prototype.open = function() {\n          return $q((function(_this) {\n            return function(resolve) {\n              return _this.db.open()[\"catch\"](function(e) {\n                return $log.error('indexedDBService: open', e);\n              })[\"finally\"](function() {\n                return resolve();\n              });\n            };\n          })(this));\n        };\n\n        IndexedDBService.prototype.clear = function() {\n          return $q((function(_this) {\n            return function(resolve) {\n              return _this.db[\"delete\"]()[\"catch\"](function(e) {\n                return $log.error('indexedDBService: clear', e);\n              })[\"finally\"](function() {\n                return _this.open().then(function() {\n                  return resolve();\n                });\n              });\n            };\n          })(this));\n        };\n\n        IndexedDBService.prototype.get = function(url, query) {\n          if (query == null) {\n            query = {};\n          }\n          return $q((function(_this) {\n            return function(resolve, reject) {\n              return _this.processUrl(url).then(function(arg) {\n                var id, q, table, tableName;\n                tableName = arg[0], q = arg[1], id = arg[2];\n                angular.extend(query, q);\n                if (SPECIFICATION[tableName] == null) {\n                  resolve([]);\n                  return;\n                }\n                table = _this.db[tableName];\n                return _this.db.transaction('r', table, function() {\n                  if (id != null) {\n                    table.get(id).then(function(e) {\n                      return resolve(dataUtilsService.parse(e));\n                    });\n                    return;\n                  }\n                  return table.toArray().then(function(array) {\n                    var fieldAndOperator, fields, filters, limit, offset, order, property, value;\n                    array = array.map(function(e) {\n                      return dataUtilsService.parse(e);\n                    });\n                    filters = [];\n                    for (fieldAndOperator in query) {\n                      value = query[fieldAndOperator];\n                      if (['field', 'limit', 'offset', 'order'].indexOf(fieldAndOperator) < 0) {\n                        filters[fieldAndOperator] = value;\n                      }\n                    }\n                    array = _this.filter(array, filters, tableName);\n                    order = query != null ? query.order : void 0;\n                    array = _this.sort(array, order);\n                    offset = query != null ? query.offset : void 0;\n                    limit = query != null ? query.limit : void 0;\n                    array = _this.paginate(array, offset, limit);\n                    property = query != null ? query.property : void 0;\n                    array = _this.properties(array, property);\n                    fields = query != null ? query.field : void 0;\n                    array = _this.fields(array, fields);\n                    return resolve(array);\n                  });\n                });\n              });\n            };\n          })(this));\n        };\n\n        IndexedDBService.prototype.filter = function(array, filters, tableName) {\n          return array.filter(function(v) {\n            var cmp, field, fieldAndOperator, operator, ref, value;\n            for (fieldAndOperator in filters) {\n              value = filters[fieldAndOperator];\n              if (['on', 'true', 'yes'].indexOf(value) > -1) {\n                value = true;\n              } else if (['off', 'false', 'no'].indexOf(value) > -1) {\n                value = false;\n              }\n              ref = fieldAndOperator.split('__'), field = ref[0], operator = ref[1];\n              switch (operator) {\n                case 'ne':\n                  cmp = v[field] !== value;\n                  break;\n                case 'lt':\n                  cmp = v[field] < value;\n                  break;\n                case 'le':\n                  cmp = v[field] <= value;\n                  break;\n                case 'gt':\n                  cmp = v[field] > value;\n                  break;\n                case 'ge':\n                  cmp = v[field] >= value;\n                  break;\n                default:\n                  cmp = v[field] === value || (angular.isArray(v[field]) && indexOf.call(v[field], value) >= 0) || v[\"_\" + field] === value || (angular.isArray(v[\"_\" + field]) && indexOf.call(v[\"_\" + field], value) >= 0);\n              }\n              if (!cmp) {\n                return false;\n              }\n            }\n            return true;\n          });\n        };\n\n        IndexedDBService.prototype.sort = function(array, order) {\n          var compare, copy;\n          compare = function(property) {\n            var reverse;\n            if (property[0] === '-') {\n              property = property.slice(1);\n              reverse = true;\n            }\n            return function(a, b) {\n              var ref;\n              if (reverse) {\n                ref = [b, a], a = ref[0], b = ref[1];\n              }\n              if (a[property] < b[property]) {\n                return -1;\n              } else if (a[property] > b[property]) {\n                return 1;\n              } else {\n                return 0;\n              }\n            };\n          };\n          copy = array.slice(0);\n          if (angular.isString(order)) {\n            copy.sort(compare(order));\n          } else if (angular.isArray(order)) {\n            copy.sort(function(a, b) {\n              var f, j, len, o;\n              for (j = 0, len = order.length; j < len; j++) {\n                o = order[j];\n                f = compare(o)(a, b);\n                if (f) {\n                  return f;\n                }\n              }\n              return 0;\n            });\n          }\n          return copy;\n        };\n\n        IndexedDBService.prototype.paginate = function(array, offset, limit) {\n          var end;\n          if (offset == null) {\n            offset = 0;\n          }\n          if (offset >= array.length) {\n            return [];\n          }\n          if ((limit == null) || offset + limit > array.length) {\n            end = array.length;\n          } else {\n            end = offset + limit - 1;\n          }\n          return array.slice(offset, +end + 1 || 9e9);\n        };\n\n        IndexedDBService.prototype.properties = function(array, properties) {\n          return array;\n        };\n\n        IndexedDBService.prototype.fields = function(array, fields) {\n          var element, j, key, len;\n          if (fields == null) {\n            return array;\n          }\n          if (!angular.isArray(fields)) {\n            fields = [fields];\n          }\n          for (j = 0, len = array.length; j < len; j++) {\n            element = array[j];\n            for (key in element) {\n              if (indexOf.call(fields, key) < 0) {\n                delete element[key];\n              }\n            }\n          }\n          return array;\n        };\n\n        IndexedDBService.prototype.processUrl = function(url) {\n          return $q((function(_this) {\n            return function(resolve, reject) {\n              var fieldName, fieldType, fieldValue, id, match, nextUrl, parentFieldName, parentFieldValue, parentId, parentName, path, pathString, query, ref, ref1, ref2, ref3, root, specification, splitted, tableName;\n              ref = url.split('/'), root = ref[0], id = ref[1], path = 3 <= ref.length ? slice.call(ref, 2) : [];\n              specification = SPECIFICATION[root];\n              query = {};\n              if (path.length === 0) {\n                id = dataUtilsService.numberOrString(id);\n                if (angular.isString(id) && specification.identifier) {\n                  query[specification.identifier] = id;\n                  id = null;\n                }\n                resolve([root, query, id]);\n                return;\n              }\n              pathString = path.join('/');\n              match = specification.paths.filter(function(p) {\n                var replaced;\n                replaced = p.replace(RegExp(SPECIFICATION.FIELDTYPES.IDENTIFIER + \"\\\\:\\\\w+\", \"g\"), '[a-zA-Z]+').replace(RegExp(SPECIFICATION.FIELDTYPES.NUMBER + \"\\\\:\\\\w+\", \"g\"), '\\\\d+');\n                return RegExp(\"^\" + replaced + \"$\").test(pathString);\n              }).pop();\n              if (match == null) {\n                throw new Error(\"No child path (\" + (path.join('/')) + \") found for root (\" + root + \")\");\n              }\n              match = match.split('/');\n              if (path.length % 2 === 0) {\n                fieldValue = dataUtilsService.numberOrString(path.pop());\n                ref1 = match.pop().split(':'), fieldType = ref1[0], fieldName = ref1[1];\n              }\n              tableName = path.pop();\n              match.pop();\n              parentFieldValue = dataUtilsService.numberOrString(path.pop() || id);\n              parentFieldName = ((ref2 = match.pop()) != null ? ref2.split(':').pop() : void 0) || SPECIFICATION[root].id;\n              parentName = match.pop() || root;\n              parentId = SPECIFICATION[parentName].id;\n              if (fieldName === ((ref3 = SPECIFICATION[tableName]) != null ? ref3.id : void 0)) {\n                id = fieldValue;\n                return resolve([tableName, query, id]);\n              } else {\n                if (parentFieldName !== parentId) {\n                  splitted = url.split('/');\n                  nextUrl = splitted.slice(0, (splitted.length % 2 === 0 ? -2 : -1)).join('/');\n                  return _this.get(nextUrl).then(function(array) {\n                    query[parentId] = array[0][parentId];\n                    if (fieldName != null) {\n                      query[fieldName] = fieldValue;\n                    }\n                    return resolve([tableName, query, null]);\n                  });\n                } else {\n                  query[parentFieldName] = parentFieldValue;\n                  if (fieldName != null) {\n                    query[fieldName] = fieldValue;\n                  }\n                  return resolve([tableName, query, null]);\n                }\n              }\n            };\n          })(this));\n        };\n\n        IndexedDBService.prototype.processSpecification = function(specification) {\n          var a, i, name, s, stores;\n          stores = {};\n          for (name in specification) {\n            s = specification[name];\n            if (angular.isArray(s.fields)) {\n              a = s.fields.slice(0);\n              i = a.indexOf(s.id);\n              if (i > -1) {\n                a[i] = \"&\" + a[i];\n              } else {\n                a.unshift('++id');\n              }\n              stores[name] = a.join(',');\n            }\n          }\n          return stores;\n        };\n\n        return IndexedDBService;\n\n      })());\n    }\n\n    return IndexedDB;\n\n  })();\n\n  angular.module('bbData').service('indexedDBService', ['$log', '$injector', '$q', '$window', 'dataUtilsService', 'DBSTORES', 'SPECIFICATION', IndexedDB]);\n\n}).call(this);\n\n(function() {\n  var Rest,\n    slice = [].slice;\n\n  Rest = (function() {\n    function Rest($http, $q, API) {\n      var RestService;\n      return new (RestService = (function() {\n        function RestService() {}\n\n        RestService.prototype.execute = function(config) {\n          return $q((function(_this) {\n            return function(resolve, reject) {\n              return $http(config).success(function(response) {\n                var data, e, error;\n                try {\n                  data = angular.fromJson(response);\n                  return resolve(data);\n                } catch (error) {\n                  e = error;\n                  return reject(e);\n                }\n              }).error(function(reason) {\n                return reject(reason);\n              });\n            };\n          })(this));\n        };\n\n        RestService.prototype.get = function(url, params) {\n          var config;\n          if (params == null) {\n            params = {};\n          }\n          config = {\n            method: 'GET',\n            url: this.parse(API, url),\n            params: params,\n            headers: {\n              'Accept': 'application/json'\n            }\n          };\n          return this.execute(config);\n        };\n\n        RestService.prototype.post = function(url, data) {\n          var config;\n          if (data == null) {\n            data = {};\n          }\n          config = {\n            method: 'POST',\n            url: this.parse(API, url),\n            data: data,\n            headers: {\n              'Content-Type': 'application/json'\n            }\n          };\n          return this.execute(config);\n        };\n\n        RestService.prototype.parse = function() {\n          var args;\n          args = 1 <= arguments.length ? slice.call(arguments, 0) : [];\n          return args.join('/').replace(/\\/\\//, '/');\n        };\n\n        return RestService;\n\n      })());\n    }\n\n    return Rest;\n\n  })();\n\n  angular.module('bbData').service('restService', ['$http', '$q', 'API', Rest]);\n\n}).call(this);\n\n(function() {\n  var Socket;\n\n  Socket = (function() {\n    function Socket($log, $q, $location, $window, webSocketBackendService) {\n      var SocketService;\n      return new (SocketService = (function() {\n        function SocketService() {}\n\n        SocketService.prototype.queue = [];\n\n        SocketService.prototype.deferred = {};\n\n        SocketService.prototype.onMessage = null;\n\n        SocketService.prototype.onClose = null;\n\n        SocketService.prototype.open = function() {\n          if (this.socket == null) {\n            this.socket = this.getWebSocket();\n          }\n          this.socket.onopen = (function(_this) {\n            return function() {\n              return _this.flush();\n            };\n          })(this);\n          this.socket.onmessage = (function(_this) {\n            return function(message) {\n              var code, data, e, error, error1, id, key, ref, ref1, ref2, ref3;\n              try {\n                data = angular.fromJson(message.data);\n                $log.debug('WS message', data);\n                if (data._id != null) {\n                  ref = [data.msg, data.error, data._id, data.code], message = ref[0], error = ref[1], id = ref[2], code = ref[3];\n                  if (code === 200) {\n                    return (ref1 = _this.deferred[id]) != null ? ref1.resolve(message) : void 0;\n                  } else {\n                    return (ref2 = _this.deferred[id]) != null ? ref2.reject(error) : void 0;\n                  }\n                } else {\n                  ref3 = [data.k, data.m], key = ref3[0], message = ref3[1];\n                  return typeof _this.onMessage === \"function\" ? _this.onMessage(key, message) : void 0;\n                }\n              } catch (error1) {\n                e = error1;\n                return $log.error(e);\n              }\n            };\n          })(this);\n          return this.socket.onclose = (function(_this) {\n            return function() {\n              return typeof _this.onClose === \"function\" ? _this.onClose() : void 0;\n            };\n          })(this);\n        };\n\n        SocketService.prototype.close = function() {\n          var ref;\n          return (ref = this.socket) != null ? ref.close() : void 0;\n        };\n\n        SocketService.prototype.send = function(data) {\n          var base, id;\n          id = this.nextId();\n          data._id = id;\n          if ((base = this.deferred)[id] == null) {\n            base[id] = $q.defer();\n          }\n          data = angular.toJson(data);\n          if (this.socket.readyState === (this.socket.OPEN || 1)) {\n            $log.debug('WS send', angular.fromJson(data));\n            this.socket.send(data);\n          } else {\n            this.queue.push(data);\n          }\n          return this.deferred[id].promise;\n        };\n\n        SocketService.prototype.flush = function() {\n          var data, results;\n          results = [];\n          while (data = this.queue.shift()) {\n            $log.debug('WS send', angular.fromJson(data));\n            results.push(this.socket.send(data));\n          }\n          return results;\n        };\n\n        SocketService.prototype.nextId = function() {\n          if (this.id == null) {\n            this.id = 0;\n          }\n          this.id = this.id < 1000 ? this.id + 1 : 0;\n          return this.id;\n        };\n\n        SocketService.prototype.getRootPath = function() {\n          return location.pathname;\n        };\n\n        SocketService.prototype.getUrl = function() {\n          var defaultport, host, path, port, protocol;\n          host = $location.host();\n          protocol = $location.protocol() === 'https' ? 'wss' : 'ws';\n          defaultport = $location.protocol() === 'https' ? 443 : 80;\n          path = this.getRootPath();\n          port = $location.port() === defaultport ? '' : ':' + $location.port();\n          return protocol + \"://\" + host + port + path + \"ws\";\n        };\n\n        SocketService.prototype.getWebSocket = function() {\n          var url;\n          url = this.getUrl();\n          if (typeof jasmine !== \"undefined\" && jasmine !== null) {\n            return webSocketBackendService.getWebSocket();\n          }\n          if ($window.ReconnectingWebSocket != null) {\n            return new $window.ReconnectingWebSocket(url);\n          }\n          return new $window.WebSocket(url);\n        };\n\n        return SocketService;\n\n      })());\n    }\n\n    return Socket;\n\n  })();\n\n  angular.module('bbData').service('socketService', ['$log', '$q', '$location', '$window', 'webSocketBackendService', Socket]);\n\n}).call(this);\n\n(function() {\n  var WebSocketBackend;\n\n  WebSocketBackend = (function() {\n    var MockWebSocket, self;\n\n    self = null;\n\n    function WebSocketBackend() {\n      self = this;\n      this.webSocket = new MockWebSocket();\n    }\n\n    WebSocketBackend.prototype.sendQueue = [];\n\n    WebSocketBackend.prototype.receiveQueue = [];\n\n    WebSocketBackend.prototype.send = function(message) {\n      var data;\n      data = {\n        data: message\n      };\n      return this.sendQueue.push(data);\n    };\n\n    WebSocketBackend.prototype.flush = function() {\n      var message, results;\n      results = [];\n      while (message = this.sendQueue.shift()) {\n        results.push(this.webSocket.onmessage(message));\n      }\n      return results;\n    };\n\n    WebSocketBackend.prototype.getWebSocket = function() {\n      return this.webSocket;\n    };\n\n    MockWebSocket = (function() {\n      function MockWebSocket() {}\n\n      MockWebSocket.prototype.OPEN = 1;\n\n      MockWebSocket.prototype.send = function(message) {\n        return self.receiveQueue.push(message);\n      };\n\n      MockWebSocket.prototype.close = function() {\n        return typeof this.onclose === \"function\" ? this.onclose() : void 0;\n      };\n\n      return MockWebSocket;\n\n    })();\n\n    return WebSocketBackend;\n\n  })();\n\n  angular.module('bbData').service('webSocketBackendService', [WebSocketBackend]);\n\n}).call(this);\n\n(function() {\n  var Tabex,\n    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },\n    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },\n    slice = [].slice;\n\n  Tabex = (function() {\n    function Tabex($log, $window, $q, $timeout, socketService, restService, dataUtilsService, indexedDBService, SPECIFICATION) {\n      var TabexService;\n      return new (TabexService = (function() {\n        var CHANNELS, EVENTS, ROLES;\n\n        CHANNELS = {\n          MASTER: '!sys.master',\n          REFRESH: '!sys.channels.refresh'\n        };\n\n        ROLES = {\n          MASTER: 'bb.role.master',\n          SLAVE: 'bb.role.slave'\n        };\n\n        TabexService.prototype._ROLES = ROLES;\n\n        EVENTS = {\n          READY: 'bb.event.ready',\n          UPDATE: 'bb.event.update',\n          NEW: 'bb.event.new'\n        };\n\n        TabexService.prototype.EVENTS = EVENTS;\n\n        TabexService.prototype.client = $window.tabex.client();\n\n        function TabexService() {\n          this.closeHandler = bind(this.closeHandler, this);\n          this.messageHandler = bind(this.messageHandler, this);\n          this.refreshHandler = bind(this.refreshHandler, this);\n          this.masterHandler = bind(this.masterHandler, this);\n          socketService.onMessage = this.messageHandler;\n          socketService.onClose = this.closeHandler;\n          this.initialRoleDeferred = $q.defer();\n          this.initialRole = this.initialRoleDeferred.promise;\n          this.client.on(CHANNELS.MASTER, this.masterHandler);\n          this.client.on(CHANNELS.REFRESH, this.refreshHandler);\n          $window.onunload = $window.onbeforeunload = (function(_this) {\n            return function(e) {\n              _this.activatePaths();\n              return null;\n            };\n          })(this);\n        }\n\n        TabexService.prototype.getSpecification = function(type) {\n          return SPECIFICATION[type];\n        };\n\n        TabexService.prototype.masterHandler = function(data) {\n          if (data.node_id === data.master_id) {\n            this.role = ROLES.MASTER;\n            this.initialRoleDeferred.resolve();\n            return socketService.open();\n          } else {\n            this.role = ROLES.SLAVE;\n            this.initialRoleDeferred.resolve();\n            return socketService.close();\n          }\n        };\n\n        TabexService.prototype.refreshHandler = function(data) {\n          return this.initialRole.then((function(_this) {\n            return function() {\n              if (_this.role === ROLES.MASTER) {\n                return _this.masterRefreshHandler(data);\n              }\n            };\n          })(this));\n        };\n\n        TabexService.prototype.debounceTimeout = 100;\n\n        TabexService.prototype.trackedPaths = {};\n\n        TabexService.prototype.consuming = {};\n\n        TabexService.prototype.masterRefreshHandler = function(data) {\n          if (this.timeoutPromise != null) {\n            $timeout.cancel(this.timeoutPromise);\n          }\n          return this.timeoutPromise = $timeout((function(_this) {\n            return function() {\n              return _this.activatePaths().then(function() {\n                var channel, channels, e, error1, l, len, name1, paths, r;\n                channels = data.channels.filter(function(c) {\n                  return c.indexOf('!sys.') !== 0;\n                });\n                paths = {};\n                for (l = 0, len = channels.length; l < len; l++) {\n                  channel = channels[l];\n                  try {\n                    r = angular.fromJson(channel);\n                    if (paths[name1 = r.path] == null) {\n                      paths[name1] = [];\n                    }\n                    paths[r.path].push(r.query);\n                  } catch (error1) {\n                    e = error1;\n                    $log.error('channel is not a JSON string', channel);\n                    return;\n                  }\n                }\n                return _this.startConsumingAll(paths).then(function() {\n                  var path;\n                  for (path in _this.consuming) {\n                    if (!(path in paths)) {\n                      _this.stopConsuming(path);\n                      delete _this.consuming[path];\n                    }\n                  }\n                  _this.trackedPaths = paths;\n                  return _this.loadAll(paths);\n                });\n              });\n            };\n          })(this), this.debounceTimeout);\n        };\n\n        TabexService.prototype.messageHandler = function(key, message) {\n          var event, id, ref, type;\n          ref = key.split('/').slice(-3), type = ref[0], id = ref[1], event = ref[2];\n          if (event === 'new') {\n            event = EVENTS.NEW;\n          } else {\n            event = EVENTS.UPDATE;\n          }\n          return indexedDBService.db[type].put(message).then((function(_this) {\n            return function() {\n              var path, query, results;\n              results = [];\n              for (path in _this.trackedPaths) {\n                if (RegExp(\"^\" + (path.replace(/\\*/g, '(\\\\w+|\\\\d+)')) + \"$\").test(key)) {\n                  results.push((function() {\n                    var l, len, ref1, results1;\n                    ref1 = this.trackedPaths[path];\n                    results1 = [];\n                    for (l = 0, len = ref1.length; l < len; l++) {\n                      query = ref1[l];\n                      results1.push(this.emit(path, query, event));\n                    }\n                    return results1;\n                  }).call(_this));\n                } else {\n                  results.push(void 0);\n                }\n              }\n              return results;\n            };\n          })(this));\n        };\n\n        TabexService.prototype.closeHandler = function() {\n          var paths;\n          paths = angular.copy(this.trackedPaths);\n          this.trackedPaths = {};\n          return this.startConsumingAll(paths);\n        };\n\n        TabexService.prototype.loadAll = function(paths) {\n          var db;\n          db = indexedDBService.db;\n          return db.paths.toArray().then((function(_this) {\n            return function(dbPaths) {\n              var path, queries, query, results;\n              results = [];\n              for (path in paths) {\n                queries = paths[path];\n                results.push((function() {\n                  var l, len, results1;\n                  results1 = [];\n                  for (l = 0, len = queries.length; l < len; l++) {\n                    query = queries[l];\n                    results1.push(this.load(path, query, dbPaths));\n                  }\n                  return results1;\n                }).call(_this));\n              }\n              return results;\n            };\n          })(this));\n        };\n\n        TabexService.prototype.load = function(path, query, dbPaths) {\n          if (dbPaths == null) {\n            dbPaths = [];\n          }\n          return $q((function(_this) {\n            return function(resolve, reject) {\n              var active, db, dbPath, elapsed, inCache, l, len, parentId, parentIdName, parentName, ref, ref1, restPath, specification, t;\n              db = indexedDBService.db;\n              t = dataUtilsService.type(path);\n              specification = _this.getSpecification(t);\n              for (l = 0, len = dbPaths.length; l < len; l++) {\n                dbPath = dbPaths[l];\n                dbPath.query = angular.fromJson(dbPath.query);\n                inCache = (dbPath.path === path && (angular.equals(dbPath.query, query) || angular.equals(dbPath.query, {}))) || (dbPath.path === t && angular.equals(dbPath.query, {}));\n                elapsed = new Date() - new Date(dbPath.lastActive);\n                active = elapsed < 2000 || specification[\"static\"] === true;\n                if (inCache && active) {\n                  resolve();\n                  return;\n                }\n              }\n              restPath = dataUtilsService.restPath(path);\n              ref = _this.getParent(restPath), parentName = ref[0], parentId = ref[1];\n              parentIdName = (ref1 = SPECIFICATION[parentName]) != null ? ref1.id : void 0;\n              if (parentIdName != null) {\n                parentIdName = \"_\" + parentIdName;\n              }\n              return restService.get(restPath, query).then(function(data) {\n                var type;\n                type = dataUtilsService.type(restPath);\n                data = dataUtilsService.unWrap(data, type);\n                return db.transaction('rw', db[type], function() {\n                  if (!angular.isArray(data)) {\n                    data = [data];\n                  }\n                  return data.forEach(function(i) {\n                    var id, idName, put, ref2;\n                    put = function(element) {\n                      var k, v;\n                      for (k in element) {\n                        v = element[k];\n                        if (angular.isObject(element[k])) {\n                          element[k] = angular.toJson(v);\n                        }\n                      }\n                      return db[type].put(element);\n                    };\n                    idName = (ref2 = SPECIFICATION[type]) != null ? ref2.id : void 0;\n                    id = i[idName];\n                    if (id != null) {\n                      return db[type].get(id).then(function(e) {\n                        var k, v;\n                        e = dataUtilsService.parse(e);\n                        for (k in i) {\n                          v = i[k];\n                          e[k] = v;\n                        }\n                        if (parentIdName != null) {\n                          if (e[parentIdName] == null) {\n                            e[parentIdName] = [];\n                          }\n                          if (indexOf.call(e[parentIdName], parentId) < 0) {\n                            e[parentIdName].push(parentId);\n                          }\n                        }\n                        return put(e);\n                      })[\"catch\"](function() {\n                        if (parentIdName != null) {\n                          i[parentIdName] = [parentId];\n                        }\n                        return put(i);\n                      });\n                    } else {\n                      if (parentIdName != null) {\n                        i[parentIdName] = [parentId];\n                      }\n                      return put(i);\n                    }\n                  });\n                }).then(function() {\n                  return db.transaction('rw', db.paths, function() {\n                    return db.paths.put({\n                      path: path,\n                      query: angular.toJson(query)\n                    });\n                  }).then(function() {\n                    return resolve();\n                  })[\"catch\"](function(error) {\n                    return reject(error);\n                  });\n                })[\"catch\"](function(error) {\n                  return reject(error);\n                });\n              }, function(error) {\n                return reject(error);\n              });\n            };\n          })(this)).then((function(_this) {\n            return function() {\n              return _this.emit(path, query, EVENTS.READY);\n            };\n          })(this), (function(_this) {\n            return function(error) {\n              return $log.error(error);\n            };\n          })(this));\n        };\n\n        TabexService.prototype.getParent = function(restPath) {\n          var id, name, path;\n          path = restPath.split('/');\n          if (path % 2 === 0) {\n            path.pop();\n          }\n          path.pop();\n          id = dataUtilsService.numberOrString(path.pop());\n          name = path.pop();\n          return [name, id];\n        };\n\n        TabexService.prototype.activatePaths = function() {\n          var db, paths;\n          paths = angular.copy(this.trackedPaths);\n          db = indexedDBService.db;\n          return db.transaction('rw', db.paths, (function(_this) {\n            return function() {\n              var now, path, queries, query, results;\n              now = (new Date()).toString();\n              results = [];\n              for (path in paths) {\n                queries = paths[path];\n                results.push((function() {\n                  var l, len, results1;\n                  results1 = [];\n                  for (l = 0, len = queries.length; l < len; l++) {\n                    query = queries[l];\n                    results1.push(db.paths.where('[path+query]').equals([path, angular.toJson(query)]).modify({\n                      'lastActive': now\n                    }));\n                  }\n                  return results1;\n                })());\n              }\n              return results;\n            };\n          })(this));\n        };\n\n        TabexService.prototype.on = function() {\n          var channel, l, listener, options, path, query, subscribe;\n          options = 2 <= arguments.length ? slice.call(arguments, 0, l = arguments.length - 1) : (l = 0, []), listener = arguments[l++];\n          path = options[0], query = options[1];\n          query = angular.copy(query) || {};\n          subscribe = query.subscribe;\n          delete query.subscribe;\n          if (subscribe === false) {\n            indexedDBService.db.paths.toArray().then((function(_this) {\n              return function(dbPaths) {\n                return _this.load(path, query, dbPaths).then(function() {\n                  return listener(EVENTS.READY);\n                });\n              };\n            })(this));\n            return;\n          }\n          channel = {\n            path: path,\n            query: query\n          };\n          return this.client.on(angular.toJson(channel), listener);\n        };\n\n        TabexService.prototype.off = function() {\n          var channel, l, listener, options, path, query;\n          options = 2 <= arguments.length ? slice.call(arguments, 0, l = arguments.length - 1) : (l = 0, []), listener = arguments[l++];\n          path = options[0], query = options[1];\n          query = angular.copy(query) || {};\n          delete query.subscribe;\n          channel = {\n            path: path,\n            query: query\n          };\n          return this.client.off(angular.toJson(channel), listener);\n        };\n\n        TabexService.prototype.emit = function() {\n          var channel, l, message, options, path, query;\n          options = 2 <= arguments.length ? slice.call(arguments, 0, l = arguments.length - 1) : (l = 0, []), message = arguments[l++];\n          path = options[0], query = options[1];\n          channel = {\n            path: path,\n            query: query || {}\n          };\n          return this.client.emit(angular.toJson(channel), message, true);\n        };\n\n        TabexService.prototype.startConsuming = function(path) {\n          return socketService.send({\n            cmd: 'startConsuming',\n            path: path\n          });\n        };\n\n        TabexService.prototype.stopConsuming = function(path) {\n          return socketService.send({\n            cmd: 'stopConsuming',\n            path: path\n          });\n        };\n\n        TabexService.prototype.startConsumingAll = function(paths) {\n          var i, j, l, len, len1, len2, len3, m, n, o, p, path, pathsToRemove, promises, q, r, socketPaths;\n          if (angular.isArray(paths)) {\n            socketPaths = paths.slice(0);\n          } else if (angular.isObject(paths)) {\n            socketPaths = Object.keys(paths);\n          } else {\n            throw new Error('Parameter paths is not an object or an array');\n          }\n          pathsToRemove = [];\n          for (i = l = 0, len = socketPaths.length; l < len; i = ++l) {\n            p = socketPaths[i];\n            r = RegExp(\"^\" + (p.replace(/\\*/g, '(\\\\w+|\\\\d+|\\\\*)')) + \"$\");\n            for (j = m = 0, len1 = socketPaths.length; m < len1; j = ++m) {\n              q = socketPaths[j];\n              if (j !== i && r.test(q)) {\n                pathsToRemove.push(q);\n              }\n            }\n          }\n          for (n = 0, len2 = pathsToRemove.length; n < len2; n++) {\n            p = pathsToRemove[n];\n            socketPaths.splice(socketPaths.indexOf(p), 1);\n          }\n          promises = [];\n          for (o = 0, len3 = socketPaths.length; o < len3; o++) {\n            path = socketPaths[o];\n            if (!(path in this.trackedPaths)) {\n              this.consuming[path] = true;\n              promises.push(this.startConsuming(path));\n            }\n          }\n          return $q.all(promises);\n        };\n\n        TabexService.prototype.mergePaths = function(dest, src) {\n          var path, queries, query, results;\n          results = [];\n          for (path in src) {\n            queries = src[path];\n            if (dest[path] == null) {\n              dest[path] = [];\n            }\n            results.push((function() {\n              var l, len, results1;\n              results1 = [];\n              for (l = 0, len = queries.length; l < len; l++) {\n                query = queries[l];\n                if (dest[path].filter(function(e) {\n                  return angular.equals(e, query);\n                }).length === 0) {\n                  results1.push(dest[path].push(query));\n                } else {\n                  results1.push(void 0);\n                }\n              }\n              return results1;\n            })());\n          }\n          return results;\n        };\n\n        return TabexService;\n\n      })());\n    }\n\n    return Tabex;\n\n  })();\n\n  angular.module('bbData').service('tabexService', ['$log', '$window', '$q', '$timeout', 'socketService', 'restService', 'dataUtilsService', 'indexedDBService', 'SPECIFICATION', Tabex]);\n\n}).call(this);\n\n(function() {\n  var Collection,\n    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },\n    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },\n    hasProp = {}.hasOwnProperty,\n    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };\n\n  Collection = (function() {\n    function Collection($q, $injector, $log, dataUtilsService, tabexService, indexedDBService, SPECIFICATION) {\n      var CollectionInstance;\n      return CollectionInstance = (function(superClass) {\n        extend(CollectionInstance, superClass);\n\n        function CollectionInstance(restPath, query) {\n          var Wrapper, ready;\n          if (query == null) {\n            query = {};\n          }\n          this.listener = bind(this.listener, this);\n          this.getRestPath = function() {\n            return restPath;\n          };\n          this.getQuery = function() {\n            return query;\n          };\n          this.getSocketPath = function() {\n            return dataUtilsService.socketPath(restPath);\n          };\n          this.getType = function() {\n            return dataUtilsService.type(restPath);\n          };\n          this.getEndpoint = function() {\n            return dataUtilsService.endpointPath(restPath);\n          };\n          this.getSpecification = function() {\n            return SPECIFICATION[this.getType()];\n          };\n          Wrapper = $injector.get('Wrapper');\n          this.getWrapper = function() {\n            return Wrapper;\n          };\n          ready = $q.defer();\n          this.getReadyDeferred = function() {\n            return ready;\n          };\n          this.getReadyPromise = function() {\n            return ready.promise;\n          };\n        }\n\n        CollectionInstance.prototype.subscribe = function() {\n          var promise;\n          tabexService.on(this.getSocketPath(), this.getQuery(), this.listener);\n          promise = this.getReadyPromise();\n          promise.getArray = (function(_this) {\n            return function() {\n              return _this;\n            };\n          })(this);\n          return promise;\n        };\n\n        CollectionInstance.prototype.unsubscribe = function() {\n          this.forEach(function(e) {\n            return e != null ? typeof e.unsubscribe === \"function\" ? e.unsubscribe() : void 0 : void 0;\n          });\n          return tabexService.off(this.getSocketPath(), this.getQuery(), this.listener);\n        };\n\n        CollectionInstance.prototype.listener = function(event) {\n          var query;\n          if (event === tabexService.EVENTS.READY && this.length !== 0) {\n            return;\n          }\n          query = angular.copy(this.getQuery());\n          delete query.subscribe;\n          return indexedDBService.get(this.getRestPath(), query).then((function(_this) {\n            return function(data) {\n              if (!angular.isArray(data)) {\n                data = [data];\n              }\n              switch (event) {\n                case tabexService.EVENTS.READY:\n                  return _this.readyHandler(data);\n                case tabexService.EVENTS.UPDATE:\n                  return _this.updateHandler(data);\n                case tabexService.EVENTS.NEW:\n                  return _this.newHandler(data);\n                default:\n                  return $log.error('Unhandled tabex event', event);\n              }\n            };\n          })(this));\n        };\n\n        CollectionInstance.prototype.readyHandler = function(data) {\n          var ref;\n          this.from(data);\n          return (ref = this.getReadyDeferred()) != null ? ref.resolve(this) : void 0;\n        };\n\n        CollectionInstance.prototype.newHandler = function(data) {\n          var id, ids;\n          id = this.getSpecification().id;\n          ids = {\n            \"new\": data.map(function(e) {\n              return e[id];\n            }),\n            old: this.map(function(e) {\n              return e[id];\n            })\n          };\n          data.forEach((function(_this) {\n            return function(e) {\n              var ref;\n              if (ref = e[id], indexOf.call(ids.old, ref) < 0) {\n                return _this.add(e);\n              }\n            };\n          })(this));\n          return this.forEach((function(_this) {\n            return function(e) {\n              var ref;\n              if (ref = e[id], indexOf.call(ids[\"new\"], ref) < 0) {\n                return _this[\"delete\"](e);\n              }\n            };\n          })(this));\n        };\n\n        CollectionInstance.prototype.updateHandler = function(data) {\n          var e, id, j, len, results;\n          this.newHandler(data);\n          id = this.getSpecification().id;\n          results = [];\n          for (j = 0, len = data.length; j < len; j++) {\n            e = data[j];\n            results.push(this.forEach(function(i) {\n              if (e[id] === i[id]) {\n                return i.update(e);\n              }\n            }));\n          }\n          return results;\n        };\n\n        CollectionInstance.prototype.from = function(data) {\n          var i, j, len, results;\n          results = [];\n          for (j = 0, len = data.length; j < len; j++) {\n            i = data[j];\n            results.push(this.add(i));\n          }\n          return results;\n        };\n\n        CollectionInstance.prototype.add = function(element) {\n          var Wrapper, instance;\n          Wrapper = this.getWrapper();\n          instance = new Wrapper(element, this.getEndpoint(), this.getQuery().subscribe);\n          return this.push(instance);\n        };\n\n        CollectionInstance.prototype.clear = function() {\n          var results;\n          results = [];\n          while (this.length > 0) {\n            results.push(this.pop());\n          }\n          return results;\n        };\n\n        CollectionInstance.prototype[\"delete\"] = function(element) {\n          var index;\n          index = this.indexOf(element);\n          if (index > -1) {\n            return this.splice(index, 1);\n          }\n        };\n\n        return CollectionInstance;\n\n      })(Array);\n    }\n\n    return Collection;\n\n  })();\n\n  angular.module('bbData').factory('Collection', ['$q', '$injector', '$log', 'dataUtilsService', 'tabexService', 'indexedDBService', 'SPECIFICATION', Collection]);\n\n}).call(this);\n\n(function() {\n  var Wrapper,\n    slice = [].slice;\n\n  Wrapper = (function() {\n    function Wrapper($log, dataService, dataUtilsService, tabexService, SPECIFICATION) {\n      var WrapperInstance;\n      return WrapperInstance = (function() {\n        function WrapperInstance(object, endpoint, _subscribe) {\n          var endpoints;\n          this._subscribe = _subscribe;\n          if (!angular.isString(endpoint)) {\n            throw new TypeError(\"Parameter 'endpoint' must be a string, not \" + (typeof endpoint));\n          }\n          this._endpoint = endpoint;\n          this.update(object);\n          endpoints = Object.keys(SPECIFICATION);\n          this.constructor.generateFunctions(endpoints);\n        }\n\n        WrapperInstance.prototype.update = function(o) {\n          return angular.merge(this, o);\n        };\n\n        WrapperInstance.prototype.get = function() {\n          var args, base, e, fieldName, fieldType, i, id, j, last, match, options, parameter, path, pathString, ref, ref1, ref2, root, specification;\n          args = 1 <= arguments.length ? slice.call(arguments, 0) : [];\n          ref = this._endpoint.split('/'), root = ref[0], id = ref[1], path = 3 <= ref.length ? slice.call(ref, 2) : [];\n          options = 2 <= args.length ? slice.call(args, 0, i = args.length - 1) : (i = 0, []), last = args[i++];\n          if (angular.isObject(last)) {\n            pathString = path.concat('*', options).join('/');\n            if (this._subscribe != null) {\n              if ((base = args[args.length - 1]).subscribe == null) {\n                base.subscribe = this._subscribe;\n              }\n            }\n          } else {\n            pathString = path.concat('*', args).join('/');\n            if (this._subscribe != null) {\n              args.push({\n                subscribe: this._subscribe\n              });\n            }\n          }\n          if (path.length === 0) {\n            return dataService.get.apply(dataService, [this._endpoint, this.getId()].concat(slice.call(args)));\n          }\n          specification = SPECIFICATION[root];\n          match = specification.paths.filter(function(p) {\n            var replaced;\n            replaced = p.replace(/\\w+\\:\\w+/g, '(\\\\*|\\\\w+|\\\\d+)');\n            return RegExp(\"^\" + replaced + \"$\").test(pathString);\n          }).pop();\n          if (match == null) {\n            parameter = this.getId();\n          } else {\n            ref1 = match.split('/').slice(0, -1);\n            for (j = ref1.length - 1; j >= 0; j += -1) {\n              e = ref1[j];\n              if (e.indexOf(':') > -1) {\n                ref2 = e.split(':'), fieldType = ref2[0], fieldName = ref2[1];\n                parameter = this[fieldName];\n                break;\n              }\n            }\n          }\n          return dataService.get.apply(dataService, [this._endpoint, parameter].concat(slice.call(args)));\n        };\n\n        WrapperInstance.prototype.control = function(method, params) {\n          return dataService.control(this._endpoint + \"/\" + (this.getIdentifier() || this.getId()), method, params);\n        };\n\n        WrapperInstance.generateFunctions = function(endpoints) {\n          return endpoints.forEach((function(_this) {\n            return function(e) {\n              var E, base, base1, name, name1;\n              if (e === e.toUpperCase()) {\n                return;\n              }\n              E = dataUtilsService.capitalize(e);\n              if ((base = _this.prototype)[name = \"get\" + E] == null) {\n                base[name] = function() {\n                  var args;\n                  args = 1 <= arguments.length ? slice.call(arguments, 0) : [];\n                  return this.get.apply(this, [e].concat(slice.call(args)));\n                };\n              }\n              return (base1 = _this.prototype)[name1 = \"load\" + E] != null ? base1[name1] : base1[name1] = function() {\n                var args, p;\n                args = 1 <= arguments.length ? slice.call(arguments, 0) : [];\n                p = this.get.apply(this, [e].concat(slice.call(args)));\n                this[e] = p.getArray();\n                return p;\n              };\n            };\n          })(this));\n        };\n\n        WrapperInstance.prototype.getId = function() {\n          return this[this.classId()];\n        };\n\n        WrapperInstance.prototype.getIdentifier = function() {\n          return this[this.classIdentifier()];\n        };\n\n        WrapperInstance.prototype.classId = function() {\n          return SPECIFICATION[dataUtilsService.type(this._endpoint)].id;\n        };\n\n        WrapperInstance.prototype.classIdentifier = function() {\n          return SPECIFICATION[dataUtilsService.type(this._endpoint)].identifier;\n        };\n\n        WrapperInstance.prototype.unsubscribe = function() {\n          var _, e, results;\n          results = [];\n          for (_ in this) {\n            e = this[_];\n            results.push(e != null ? typeof e.unsubscribe === \"function\" ? e.unsubscribe() : void 0 : void 0);\n          }\n          return results;\n        };\n\n        return WrapperInstance;\n\n      })();\n    }\n\n    return Wrapper;\n\n  })();\n\n  angular.module('bbData').factory('Wrapper', ['$log', 'dataService', 'dataUtilsService', 'tabexService', 'SPECIFICATION', Wrapper]);\n\n}).call(this);\n","class HttpConfig extends Config\n    constructor: ($httpProvider) ->\n        # configure $http service to combine processing\n        # of multiple http responses received at around\n        # the same time via $rootScope.$applyAsync\n        $httpProvider.useApplyAsync(true)\n        ### @ngInject ###\n        $httpProvider.interceptors.push ($log, API) ->\n            return request: (config) ->\n                # log API request only\n                if config.url.indexOf(API) is 0\n                    $log.debug(\"#{config.method} #{config.url}\")\n                return config\n","class Api extends Constant\n    constructor: -> return 'api/v2/'\n","# Class specification contains the fields and paths for every type\n# n: number\n# i: identifier\nclass Specification extends Constant\n    constructor: ->\n        return {\n            FIELDTYPES:\n                IDENTIFIER: 'i'\n                NUMBER: 'n'\n\n            builds:\n                id: 'buildid'\n                fields: [\n                    'buildid'\n                    'builderid'\n                    'buildrequestid'\n                    'buildslaveid'\n                    'complete'\n                    'complete_at'\n                    'masterid'\n                    'number'\n                    'results'\n                    'started_at'\n                    'state_string'\n                ]\n                root: true\n                paths: [\n                    'changes'\n                    'properties'\n                    'steps'\n                    'steps/i:name'\n                    'steps/i:name/logs'\n                    'steps/i:name/logs/i:slug'\n                    'steps/i:name/logs/i:slug/contents'\n                    'steps/i:name/logs/i:slug/raw'\n                    'steps/n:number'\n                    'steps/n:number/logs'\n                    'steps/n:number/logs/i:slug'\n                    'steps/n:number/logs/i:slug/contents'\n                    'steps/n:number/logs/i:slug/raw'\n                ]\n                static:\n                    complete: true\n            builders:\n                id: 'builderid'\n                identifier: 'name'\n                fields: [\n                    'builderid'\n                    'description'\n                    'name'\n                    'tags'\n                ]\n                root: true\n                paths: [\n                    'forceschedulers'\n                    'buildrequests'\n                    'masters'\n                    'masters/n:masterid'\n                    'buildslaves'\n                    'buildslaves/i:name'\n                    'buildslaves/n:buildslaveid'\n                    'builds'\n                    'builds/n:number'\n                    'builds/n:number/steps'\n                    'builds/n:number/steps/i:name'\n                    'builds/n:number/steps/i:name/logs'\n                    'builds/n:number/steps/i:name/logs/i:slug'\n                    'builds/n:number/steps/i:name/logs/i:slug/contents'\n                    'builds/n:number/steps/i:name/logs/i:slug/raw'\n                    'builds/n:number/steps/n:number'\n                    'builds/n:number/steps/n:number/logs'\n                    'builds/n:number/steps/n:number/logs/i:slug'\n                    'builds/n:number/steps/n:number/logs/i:slug/contents'\n                    'builds/n:number/steps/n:number/logs/i:slug/raw'\n                ]\n                static: true\n            buildrequests:\n                id: 'buildrequestid'\n                fields: [\n                    'buildrequestid'\n                    'builderid'\n                    'buildsetid'\n                    'claimed'\n                    'claimed_at'\n                    'claimed_by_masterid'\n                    'complete'\n                    'complete_at'\n                    'priority'\n                    'results'\n                    'submitted_at'\n                    'waited_for'\n                ]\n                root: true\n                paths: [\n                    'builds'\n                ]\n                static:\n                    complete: true\n            buildsets:\n                id: 'bsid'\n                fields: [\n                    'bsid'\n                    'complete'\n                    'complete_at'\n                    'external_idstring'\n                    'parent_buildid'\n                    'parent_relationship'\n                    'reason'\n                    'results'\n                    'sourcestamps'\n                    'submitted_at'\n                ]\n                root: true\n                paths: [\n                    'properties'\n                ]\n                static:\n                    complete: true\n            buildslaves:\n                id: 'buildslaveid'\n                fields: [\n                    'buildslaveid'\n                    'configured_on'\n                    'connected_to'\n                    'name'\n                    'slaveinfo'\n                ]\n                root: true\n                paths: []\n                static: true\n            changes:\n                id: 'changeid'\n                fields: [\n                    'changeid'\n                    'author'\n                    'branch'\n                    'category'\n                    'codebase'\n                    'comments'\n                    'files'\n                    'parent_changeids'\n                    'project'\n                    'properties'\n                    'repository'\n                    'revision'\n                    'revlink'\n                    'sourcestamp'\n                    'when_timestamp'\n                ]\n                root: true\n                paths: []\n                static: true\n            changesources:\n                id: 'changesourceid'\n                fields: [\n                    'changesourceid'\n                    'master'\n                    'name'\n                ]\n                root: true\n                paths: []\n                static: true\n            forceschedulers:\n                id: 'name'\n                fields: [\n                    'name'\n                    'all_fields'\n                    'builder_names'\n                    'label'\n                ]\n                root: true\n                paths: []\n                static: true\n            masters:\n                id: 'masterid'\n                fields: [\n                    'masterid'\n                    'active'\n                    'last_active'\n                    'name'\n                ]\n                root: true\n                paths: [\n                    'builders'\n                    'builders/n:builderid'\n                    'builders/n:builderid/buildslaves'\n                    'builders/n:builderid/buildslaves/n:buildslaveid'\n                    'builders/n:builderid/buildslaves/i:name'\n                    'buildslaves'\n                    'buildslaves/i:name'\n                    'buildslaves/n:buildslaveid'\n                    'changesources'\n                    'changesources/n:changesourceid'\n                    'schedulers'\n                    'schedulers/n:schedulerid'\n                ]\n                static: true\n            schedulers:\n                id: 'schedulerid'\n                fields: [\n                    'schedulerid'\n                    'master'\n                    'name'\n                ]\n                root: true\n                paths: []\n                static: true\n            sourcestamps:\n                id: 'ssid'\n                fields: [\n                    'ssid'\n                    'branch'\n                    'codebase'\n                    'created_at'\n                    'patch'\n                    'project'\n                    'repository'\n                    'revision'\n                ]\n                root: true\n                paths: [\n                    'changes'\n                ]\n                static: true\n\n            steps:\n                id: 'stepid'\n                identifier: 'name'\n                fields: [\n                    'stepid'\n                    'buildid'\n                    'complete'\n                    'complete_at'\n                    'hidden'\n                    'name'\n                    'number'\n                    'results'\n                    'started_at'\n                    'state_string'\n                    'urls'\n                ]\n                root: false\n                paths: [\n                    'logs'\n                    'logs/i:slug'\n                    'logs/i:slug/contents'\n                    'logs/i:slug/raw'\n                ]\n                static:\n                    complete: true\n            logs:\n                id: 'logid'\n                identifier: 'slug'\n                fields: [\n                    'logid'\n                    'complete'\n                    'name'\n                    'num_lines'\n                    'slug'\n                    'stepid'\n                    'type'\n                ]\n                root: false\n                paths: [\n                    'contents'\n                    'raw'\n                ]\n                static:\n                    complete: true\n            contents:\n                id: null\n                fields: [\n                    'logid'\n                    'logchunks'\n                    'firstline'\n                ]\n                root: false\n                restField: 'logchunks'\n            properties:\n                id: null\n                fields: []\n                root: false\n    }\n","# types for generating test data: null, number, string, boolean, timestamp, <array>[], <object>, <objectName in Specification>\nclass Generator extends Service\n    self = null\n    constructor: ->\n        self = @\n\n    number: (min = 0, max = 100) ->\n        random = Math.random() * (max - min) + min\n        Math.floor(random)\n\n    ids: {}\n    id: (name = '') ->\n        self.ids[name] ?= 0\n        self.ids[name]++\n\n    boolean: -> Math.random() < 0.5\n\n    timestamp: (after = Date.now()) ->\n        date = new Date(after + self.number(1, 1000000))\n        Math.floor(date.getTime() / 1000)\n\n    string: (length) ->\n        if length? then length++\n        self.number(100, Number.MAX_VALUE).toString(36).substring(0, length)\n\n    array: (fn, args...) ->\n        times = self.number(1, 10)\n        array = []\n        for i in [1..times]\n            array.push fn(args...)\n        return array\n","class Data extends Provider\n    cache: true\n    config = null\n    constructor: ->\n        config = cache: @cache\n\n    ### @ngInject ###\n    $get: ($log, $injector, $q, $window, Collection, restService, dataUtilsService, tabexService, indexedDBService, SPECIFICATION) ->\n        return new class DataService\n            self = null\n            constructor: ->\n                self = @\n                angular.extend(@, config)\n                # generate loadXXX functions for root endpoints\n                endpoints = Object.keys(SPECIFICATION).filter (e) -> SPECIFICATION[e].id?\n                @constructor.generateEndpoints(endpoints)\n\n            clearCache: ->\n                indexedDBService.clear().then ->\n                    if $injector.has('$state')\n                        $injector.get('$state').reload()\n                    else if $injector.has('$route')\n                        $injector.get('$route').reload()\n                    else\n                        $window.location.reload()\n\n            # the arguments are in this order: endpoint, id, child, id of child, query\n            get: (args...) ->\n\n                [restPath, query] = @processArguments(args)\n                query.subscribe ?= false\n\n                # up to date collection, this will be returned\n                collection = @createCollection(restPath, query)\n                collection.subscribe()\n\n            # register return values for the mocked get function\n            mocks: {}\n            spied: false\n            when: (args...) ->\n                [url, query, returnValue] = args\n                if not returnValue?\n                    [query, returnValue] = [{}, query]\n                if jasmine? and not @spied\n                    spyOn(@, 'get').and.callFake(@_mockGet)\n                    @spied = true\n\n                @mocks[url] ?= {}\n                @mocks[url][query] = returnValue\n\n            # register return values with the .when function\n            # when testing get will return the given values\n            _mockGet: (args...) ->\n                [url, query] = @processArguments(args)\n                queryWithoutSubscribe = angular.copy(query)\n                delete queryWithoutSubscribe.subscribe\n                returnValue = @mocks[url]?[query] or @mocks[url]?[queryWithoutSubscribe]\n                if not returnValue? then throw new Error(\"No return value for: #{url} (#{angular.toJson(query)})\")\n                collection = @createCollection(url, query)\n                collection.from(returnValue)\n                p = $q.resolve(collection)\n                p.getArray = -> collection\n                return p\n\n            # for easier testing\n            createCollection: (args...) ->\n                new Collection(args...)\n\n            processArguments: (args) ->\n                # keep defined arguments only\n                args.filter (e) -> e?\n                # get the query parameters\n                [..., last] = args\n                if angular.isObject(last)\n                    query = args.pop()\n                restPath = dataUtilsService.restPath(args)\n                return [restPath, query or {}]\n\n            control: (url, method, params = {}) ->\n                @jsonrpc ?= 1\n                restService.post url,\n                    id: @jsonrpc++\n                    jsonrpc: '2.0'\n                    method: method\n                    params: params\n\n            # generate functions for root endpoints\n            @generateEndpoints: (endpoints) ->\n                endpoints.forEach (e) =>\n                    # capitalize endpoint names\n                    E = dataUtilsService.capitalize(e)\n                    @::[\"get#{E}\"] = (args...) =>\n                        self.get(e, args...)\n\n            # opens a new accessor\n            open: (scope) ->\n                return new class DataAccessor\n                    collections = []\n                    constructor: ->\n                        @collections = collections\n                        # generate getXXX functions for root endpoints\n                        endpoints = Object.keys(SPECIFICATION).filter (e) -> SPECIFICATION[e].id?\n                        @constructor.generateEndpoints(endpoints)\n\n                        if scope? then @closeOnDestroy(scope)\n\n                    # calls unsubscribe on each root classes\n                    close: ->\n                        collections.forEach (c) -> c.unsubscribe?()\n\n                    # closes the group when the scope is destroyed\n                    closeOnDestroy: (scope) ->\n                        if not angular.isFunction(scope.$on)\n                            throw new Error(\"Parameter 'scope' doesn't have an $on function\")\n                        scope.$on '$destroy', => @close()\n\n                    # generate functions for root endpoints\n                    @generateEndpoints: (endpoints) ->\n                        endpoints.forEach (e) =>\n                            E = dataUtilsService.capitalize(e)\n                            @::[\"get#{E}\"] = (args...) =>\n                                last = args[args.length - 1]\n                                if angular.isObject(last)\n                                    last.subscribe ?= true\n                                else args.push(subscribe: true)\n                                p = self[\"get#{E}\"](args...)\n                                collections.push(p.getArray())\n                                return p\n","class DBStores extends Constant\n    constructor: ->\n        return {\n            paths: '&[path+query],path,query,lastActive'\n        }\n","class DataUtils extends Service\n    constructor: (SPECIFICATION) ->\n        return new class dataUtilsService\n            # capitalize first word\n            capitalize: (string) ->\n                string[0].toUpperCase() + string[1..].toLowerCase()\n\n            # returns the type of the endpoint\n            type: (arg) ->\n                a = @copyOrSplit(arg)\n                a = a.filter (e) -> e isnt '*'\n                # if the argument count is even, the last argument is an id\n                if a.length % 2 is 0 then a.pop()\n                a.pop()\n\n            # singularize the type name\n            singularType: (arg) ->\n                @type(arg).replace(/s$/, '')\n\n            socketPath: (arg) ->\n                a = @copyOrSplit(arg)\n                # if the argument count is even, the last argument is an id\n                stars = ['*']\n                # is it odd?\n                if a.length % 2 is 1 then stars.push('*')\n                a.concat(stars).join('/')\n\n            restPath: (arg) ->\n                a = @copyOrSplit(arg)\n                a = a.filter (e) -> e isnt '*'\n                a.join('/')\n\n            endpointPath: (arg) ->\n                # if the argument count is even, the last argument is an id\n                a = @copyOrSplit(arg)\n                a = a.filter (e) -> e isnt '*'\n                # is it even?\n                if a.length % 2 is 0 then a.pop()\n                a.join('/')\n\n            copyOrSplit: (arrayOrString) ->\n                if angular.isArray(arrayOrString)\n                    # return a copy\n                    arrayOrString[..]\n                else if angular.isString(arrayOrString)\n                    # split the string to get an array\n                    arrayOrString.split('/')\n                else\n                    throw new TypeError(\"Parameter 'arrayOrString' must be a array or a string, not #{typeof arrayOrString}\")\n\n            unWrap: (data, path) ->\n                type = @type(path)\n                type = SPECIFICATION[type]?.restField or type\n                data[type]\n\n            parse: (object) ->\n                for k, v of object\n                    try\n                        object[k] = angular.fromJson(v)\n                    catch error then # ignore\n                return object\n\n            numberOrString: (str = null) ->\n                # if already a number\n                if angular.isNumber(str) then return str\n                # else parse string to integer\n                number = parseInt str, 10\n                if !isNaN(number) then number else str\n\n            emailInString: (string) ->\n                if not angular.isString(string)\n                    throw new TypeError(\"Parameter 'string' must be a string, not #{typeof string}\")\n                emailRegex = /[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*/\n                emailRegex.exec(string).pop() or ''\n","class IndexedDB extends Service\n    constructor: ($log, $injector, $q, $window, dataUtilsService, DBSTORES, SPECIFICATION) ->\n        return new class IndexedDBService\n            constructor: ->\n                @db = new $window.Dexie('BBCache')\n                stores = {}\n                angular.extend stores, @processSpecification(SPECIFICATION), DBSTORES\n                @db.version(1).stores(stores)\n\n                # global db error handler\n                @db.on 'error', (e) -> $log.error(e)\n                # open the database\n                @open()\n\n            open: ->\n                $q (resolve) =>\n                    @db.open()\n                    .catch (e) -> $log.error 'indexedDBService: open', e\n                    .finally -> resolve()\n\n            clear: ->\n                $q (resolve) =>\n                    @db.delete()\n                    .catch (e) -> $log.error 'indexedDBService: clear', e\n                    .finally => @open().then -> resolve()\n\n            get: (url, query = {}) ->\n                $q (resolve, reject) =>\n                    @processUrl(url).then ([tableName, q, id]) =>\n                        angular.extend query, q\n\n                        if not SPECIFICATION[tableName]?\n                            resolve([])\n                            return\n\n                        table = @db[tableName]\n                        @db.transaction 'r', table, =>\n\n                            # convert promise to $q implementation\n                            if id?\n                                table.get(id).then (e) => resolve dataUtilsService.parse(e)\n                                return\n\n                            table.toArray().then (array) =>\n                                array = array.map (e) => dataUtilsService.parse(e)\n\n                                # 1. filtering\n                                filters = []\n                                for fieldAndOperator, value of query\n                                    if ['field', 'limit', 'offset', 'order'].indexOf(fieldAndOperator) < 0\n                                        filters[fieldAndOperator] = value\n                                array = @filter(array, filters, tableName)\n\n                                # 2. sorting\n                                order = query?.order\n                                array = @sort(array, order)\n\n                                # 3. pagination\n                                offset = query?.offset\n                                limit = query?.limit\n                                array = @paginate(array, offset, limit)\n\n                                # TODO 4. properties\n                                property = query?.property\n                                array = @properties(array, property)\n\n                                # 5. fields\n                                fields = query?.field\n                                array = @fields(array, fields)\n\n                                resolve(array)\n\n            filter: (array, filters, tableName) ->\n                array.filter (v) ->\n                    for fieldAndOperator, value of filters\n                        if ['on', 'true', 'yes'].indexOf(value) > -1 then value = true\n                        else if ['off', 'false', 'no'].indexOf(value) > -1 then value = false\n                        [field, operator] = fieldAndOperator.split('__')\n                        switch operator\n                            when 'ne' then cmp = v[field] != value\n                            when 'lt' then cmp = v[field] <  value\n                            when 'le' then cmp = v[field] <= value\n                            when 'gt' then cmp = v[field] >  value\n                            when 'ge' then cmp = v[field] >= value\n                            else cmp = v[field] == value or\n                                (angular.isArray(v[field]) and value in v[field]) or\n                                # private fields added by the data service\n                                v[\"_#{field}\"] == value or\n                                (angular.isArray(v[\"_#{field}\"]) and value in v[\"_#{field}\"])\n                        if !cmp then return false\n                    return true\n\n            sort: (array, order) ->\n                compare = (property) ->\n                    if property[0] is '-'\n                        property = property[1..]\n                        reverse = true\n\n                    return (a, b) ->\n                        if reverse then [a, b] = [b, a]\n\n                        if a[property] < b[property] then -1\n                        else if a[property] > b[property] then 1\n                        else 0\n\n                copy = array[..]\n                if angular.isString(order)\n                    copy.sort compare(order)\n                else if angular.isArray(order)\n                    copy.sort (a, b) ->\n                        for o in order\n                            f = compare(o)(a, b)\n                            if f then return f\n                        return 0\n\n                return copy\n\n            paginate: (array, offset, limit) ->\n                offset ?= 0\n                if offset >= array.length\n                    return []\n\n                if not limit? or offset + limit > array.length\n                    end = array.length\n                else\n                    end = offset + limit - 1\n\n                return array[offset..end]\n\n            # TODO\n            properties: (array, properties) ->\n                return array\n\n            fields: (array, fields) ->\n                if not fields?\n                    return array\n\n                if not angular.isArray(fields) then fields = [fields]\n\n                for element in array\n                    for key of element\n                        if key not in fields\n                            delete element[key]\n\n                return array\n\n            processUrl: (url) ->\n                $q (resolve, reject) =>\n                    [root, id, path...] = url.split('/')\n                    specification = SPECIFICATION[root]\n                    query = {}\n                    if path.length == 0\n                        id = dataUtilsService.numberOrString(id)\n                        if angular.isString(id) and specification.identifier\n                            query[specification.identifier] = id\n                            id = null\n                        resolve [root, query, id]\n                        return\n\n                    pathString = path.join('/')\n                    match = specification.paths.filter (p) ->\n                        replaced = p\n                            .replace ///#{SPECIFICATION.FIELDTYPES.IDENTIFIER}\\:\\w+///g, '[a-zA-Z]+'\n                            .replace ///#{SPECIFICATION.FIELDTYPES.NUMBER}\\:\\w+///g, '\\\\d+'\n                        ///^#{replaced}$///.test(pathString)\n                    .pop()\n                    if not match?\n                        throw new Error(\"No child path (#{path.join('/')}) found for root (#{root})\")\n\n                    match = match.split('/')\n\n                    if path.length % 2 is 0\n                        fieldValue = dataUtilsService.numberOrString path.pop()\n                        [fieldType, fieldName] = match.pop().split(':')\n                    tableName = path.pop()\n                    match.pop()\n                    parentFieldValue = dataUtilsService.numberOrString(path.pop() or id)\n                    parentFieldName = match.pop()?.split(':').pop() or SPECIFICATION[root].id\n                    parentName = match.pop() or root\n                    parentId = SPECIFICATION[parentName].id\n\n                    if fieldName is SPECIFICATION[tableName]?.id\n                        id = fieldValue\n                        resolve [tableName, query, id]\n                    else\n                        if parentFieldName isnt parentId\n                            splitted = url.split('/')\n                            nextUrl = splitted[...(if splitted.length % 2 == 0 then -2 else -1)].join('/')\n                            @get(nextUrl).then (array) ->\n                                query[parentId] = array[0][parentId]\n                                if fieldName? then query[fieldName] = fieldValue\n                                resolve [tableName, query, null]\n                        else\n                            query[parentFieldName] = parentFieldValue\n                            if fieldName? then query[fieldName] = fieldValue\n                            resolve [tableName, query, null]\n\n            processSpecification: (specification) ->\n                # IndexedDB tables\n                stores = {}\n                for name, s of specification\n                    if angular.isArray(s.fields)\n                        a = s.fields[..]\n                        i = a.indexOf(s.id)\n                        if i > -1 then a[i] = \"&#{a[i]}\"\n                        else a.unshift('++id')\n                        stores[name] = a.join(',')\n                return stores\n","class Rest extends Service\n    constructor: ($http, $q, API) ->\n        return new class RestService\n            execute: (config) ->\n                $q (resolve, reject) =>\n                    $http(config)\n                    .success (response) ->\n                        try\n                            data = angular.fromJson(response)\n                            resolve(data)\n                        catch e\n                            reject(e)\n                    .error (reason) -> reject(reason)\n\n            get: (url, params = {}) ->\n                config =\n                    method: 'GET'\n                    url: @parse(API, url)\n                    params: params\n                    headers:\n                      'Accept': 'application/json'\n\n                @execute(config)\n\n            post: (url, data = {}) ->\n                config =\n                    method: 'POST'\n                    url: @parse(API, url)\n                    data: data\n                    headers:\n                        'Content-Type': 'application/json'\n\n                @execute(config)\n\n            parse: (args...) ->\n                args.join('/').replace(/\\/\\//, '/')\n","class Socket extends Service\n    constructor: ($log, $q, $location, $window, webSocketBackendService) ->\n        return new class SocketService\n            # waiting queue\n            queue: []\n            # deferred object for resolving response promises\n            # map of id: promise\n            deferred: {}\n            # the onMessage(key, message) function will be called to handle an update message\n            onMessage: null\n            # the onClose() function will be called to handle the close event\n            onClose: null\n\n            open: ->\n                @socket ?= @getWebSocket()\n                # flush queue on open\n                @socket.onopen = => @flush()\n\n                @socket.onmessage = (message) =>\n                    try\n                        data = angular.fromJson(message.data)\n                        $log.debug('WS message', data)\n\n                        # response message\n                        if data._id?\n                            [message, error, id, code] = [data.msg, data.error, data._id, data.code]\n                            if code is 200 then @deferred[id]?.resolve(message)\n                            else @deferred[id]?.reject(error)\n                        # update message\n                        else\n                            [key, message] = [data.k, data.m]\n                            @onMessage?(key, message)\n\n                    catch e\n                        $log.error(e)\n\n                @socket.onclose = =>\n                    @onClose?()\n\n            close: ->\n                @socket?.close()\n\n            send: (data) ->\n                # add _id to each message\n                id = @nextId()\n                data._id = id\n                @deferred[id] ?= $q.defer()\n\n                data = angular.toJson(data)\n                # ReconnectingWebSocket does not put status constants on instance\n                if @socket.readyState is (@socket.OPEN or 1)\n                    $log.debug 'WS send', angular.fromJson(data)\n                    @socket.send(data)\n                else\n                    # if the WebSocket is not open yet, add the data to the queue\n                    @queue.push(data)\n\n                # return promise, which will be resolved once a response message has the same id\n                return @deferred[id].promise\n\n            flush: ->\n                # send all the data waiting in the queue\n                while data = @queue.shift()\n                    $log.debug 'WS send', angular.fromJson(data)\n                    @socket.send(data)\n\n            nextId: ->\n                @id ?= 0\n                @id = if @id < 1000 then @id + 1 else 0\n                return @id\n\n            getRootPath: ->\n                return location.pathname\n\n            getUrl: ->\n                host = $location.host()\n                protocol = if $location.protocol() is 'https' then 'wss' else 'ws'\n                defaultport = if $location.protocol() is 'https' then 443 else 80\n                path = @getRootPath()\n                port = if $location.port() is defaultport then '' else ':' + $location.port()\n                return \"#{protocol}://#{host}#{port}#{path}ws\"\n\n            # this function will be mocked in the tests\n            getWebSocket: ->\n                url = @getUrl()\n                # if testing, use fake implementation\n                if jasmine?\n                    return webSocketBackendService.getWebSocket()\n                # use ReconnectingWebSocket if available\n                # TODO write own implementation?\n                if $window.ReconnectingWebSocket?\n                    return new $window.ReconnectingWebSocket(url)\n                return new $window.WebSocket(url)\n","class WebSocketBackend extends Service\n    self = null\n    constructor: ->\n        self = @\n        @webSocket = new MockWebSocket()\n\n    sendQueue: []\n    receiveQueue: []\n    send: (message) ->\n        data = {data: message}\n        @sendQueue.push(data)\n\n    flush: ->\n        while message = @sendQueue.shift()\n            @webSocket.onmessage(message)\n\n    getWebSocket: ->\n        return @webSocket\n\n    # mocked WebSocket\n    class MockWebSocket\n        OPEN: 1\n        send: (message) ->\n            self.receiveQueue.push(message)\n        close: -> @onclose?()\n","class Tabex extends Service\n    constructor: ($log, $window, $q, $timeout, socketService, restService, dataUtilsService, indexedDBService, SPECIFICATION) ->\n        return new class TabexService\n            CHANNELS =\n                MASTER: '!sys.master'\n                REFRESH: '!sys.channels.refresh'\n\n            ROLES =\n                MASTER: 'bb.role.master'\n                SLAVE: 'bb.role.slave'\n            _ROLES: ROLES # used in testing\n\n            EVENTS =\n                READY: 'bb.event.ready'\n                UPDATE: 'bb.event.update'\n                NEW: 'bb.event.new'\n            EVENTS: EVENTS\n\n            client: $window.tabex.client()\n\n            constructor: ->\n                # the message handler will be called on update messages\n                socketService.onMessage = @messageHandler\n                # the close handler will be called on close event\n                # we need to resend the startConsuming messages for\n                # every tracked channels\n                socketService.onClose = @closeHandler\n\n                @initialRoleDeferred = $q.defer()\n                @initialRole = @initialRoleDeferred.promise\n\n                @client.on CHANNELS.MASTER, @masterHandler\n                @client.on CHANNELS.REFRESH, @refreshHandler\n\n                $window.onunload = $window.onbeforeunload = (e) =>\n                    @activatePaths()\n                    return null\n\n            getSpecification: (type) -> SPECIFICATION[type]\n\n            masterHandler: (data) =>\n                # the master handles the data requests and the WebSocket connection\n                if data.node_id is data.master_id\n                    @role = ROLES.MASTER\n                    @initialRoleDeferred.resolve()\n                    socketService.open()\n                else\n                    @role = ROLES.SLAVE\n                    @initialRoleDeferred.resolve()\n                    # close the WebSocket connection if it's open\n                    socketService.close()\n\n            refreshHandler: (data) =>\n                # wait for the role to be determined\n                @initialRole.then =>\n                    if @role is ROLES.MASTER then @masterRefreshHandler(data)\n\n            debounceTimeout: 100\n            # path: [query]\n            trackedPaths: {}\n            # consumed paths\n            consuming: {}\n            masterRefreshHandler: (data) ->\n                # debounce logic\n                if @timeoutPromise? then $timeout.cancel(@timeoutPromise)\n                @timeoutPromise = $timeout =>\n                    @activatePaths().then =>\n\n                        # filter channels by system channels (starts with `!sys.`)\n                        channels = data.channels.filter (c) -> c.indexOf('!sys.') != 0\n\n                        paths = {}\n                        for channel in channels\n                            try\n                                r = angular.fromJson(channel)\n                                paths[r.path] ?= []\n                                paths[r.path].push(r.query)\n                            catch e\n                                $log.error('channel is not a JSON string', channel)\n                                return\n\n                        @startConsumingAll(paths).then =>\n                            # send stopConsuming messages after we get response\n                            # for startConsuming messages, therefore no update\n                            # will be lost\n                            for path of @consuming\n                                if path not of paths\n                                    # unsubscribe removed paths\n                                    @stopConsuming(path)\n                                    delete @consuming[path]\n\n                            @trackedPaths = paths\n                            # load all tracked path into cache\n                            @loadAll(paths)\n\n                , @debounceTimeout\n\n            messageHandler: (key, message) =>\n                # ../type/id/event\n                [type, id, event] = key.split('/')[-3..]\n                # translate the event type\n                if event is 'new' then event = EVENTS.NEW\n                else event = EVENTS.UPDATE\n                # update the object in the db\n                indexedDBService.db[type].put(message).then =>\n                    # emit the event\n                    for path of @trackedPaths\n                        if ///^#{path.replace(/\\*/g, '(\\\\w+|\\\\d+)')}$///.test(key)\n                            for query in @trackedPaths[path]\n                                @emit path, query, event\n\n            closeHandler: =>\n                paths = angular.copy(@trackedPaths)\n                @trackedPaths = {}\n                @startConsumingAll(paths)\n\n            loadAll: (paths) ->\n                db = indexedDBService.db\n                db.paths.toArray().then (dbPaths) =>\n                    for path, queries of paths\n                        for query in queries\n                            @load(path, query, dbPaths)\n\n            load: (path, query, dbPaths = []) ->\n                $q (resolve, reject) =>\n                    db = indexedDBService.db\n\n                    t = dataUtilsService.type(path)\n                    specification = @getSpecification(t)\n                    # test if cached and active\n                    for dbPath in dbPaths\n                        dbPath.query = angular.fromJson(dbPath.query)\n                        inCache =\n                            (dbPath.path is path and\n                            (angular.equals(dbPath.query, query) or angular.equals(dbPath.query, {}))) or\n                            (dbPath.path is t and angular.equals(dbPath.query, {}))\n                        elapsed = new Date() - new Date(dbPath.lastActive)\n                        active = elapsed < 2000 or specification.static == true\n\n                        if inCache and active\n                            resolve()\n                            return\n\n                    restPath = dataUtilsService.restPath(path)\n                    [parentName, parentId] = @getParent(restPath)\n                    parentIdName = SPECIFICATION[parentName]?.id\n                    if parentIdName? then parentIdName = \"_#{parentIdName}\"\n                    restService.get(restPath, query).then (data) =>\n                        type = dataUtilsService.type(restPath)\n                        data = dataUtilsService.unWrap(data, type)\n                        db.transaction 'rw', db[type], ->\n                            if not angular.isArray(data) then data = [data]\n                            data.forEach (i) ->\n                                put = (element) ->\n                                    for k, v of element\n                                        if angular.isObject(element[k])\n                                            element[k] = angular.toJson(v)\n                                    db[type].put(element)\n\n                                idName = SPECIFICATION[type]?.id\n                                id = i[idName]\n                                if id?\n                                    db[type].get(id).then (e) ->\n                                        e = dataUtilsService.parse(e)\n                                        for k, v of i then e[k] = v\n                                        if parentIdName?\n                                            e[parentIdName] ?= []\n                                            if parentId not in e[parentIdName]\n                                                e[parentIdName].push(parentId)\n                                        put(e)\n                                    .catch ->\n                                        if parentIdName? then i[parentIdName] = [parentId]\n                                        put(i)\n                                else\n                                    if parentIdName? then i[parentIdName] = [parentId]\n                                    put(i)\n\n                        .then ->\n                            db.transaction 'rw', db.paths, ->\n                                # cached path informations\n                                db.paths.put {\n                                    path: path\n                                    query: angular.toJson(query)\n                                }\n                            .then -> resolve()\n                            .catch (error) -> reject(error)\n                        .catch (error) -> reject(error)\n                    , (error) -> reject(error)\n\n                .then =>\n                    @emit path, query, EVENTS.READY\n                , (error) =>\n                    $log.error(error)\n\n            getParent: (restPath) ->\n                path = restPath.split('/')\n                if path % 2 == 0 then path.pop()\n                path.pop()\n                id = dataUtilsService.numberOrString path.pop()\n                name = path.pop()\n                return [name, id]\n\n            activatePaths: ->\n                paths = angular.copy(@trackedPaths)\n                db = indexedDBService.db\n                db.transaction 'rw', db.paths, =>\n                    now = (new Date()).toString()\n                    for path, queries of paths\n                        for query in queries\n                            db.paths\n                            .where('[path+query]').equals([path,angular.toJson(query)])\n                            .modify('lastActive': now)\n\n            on: (options..., listener) ->\n                [path, query] = options\n                query = angular.copy(query) or {}\n                subscribe = query.subscribe\n                delete query.subscribe\n                # if subscribe is false, we just load the data\n                if subscribe == false\n                    indexedDBService.db.paths.toArray().then (dbPaths) =>\n                        @load(path, query, dbPaths).then -> listener(EVENTS.READY)\n                    return\n                # if subscribe is true, we subscribe on events\n                channel =\n                    path: path\n                    query: query\n                @client.on angular.toJson(channel), listener\n\n            off: (options..., listener) ->\n                [path, query] = options\n                query = angular.copy(query) or {}\n                delete query.subscribe\n\n                channel =\n                    path: path\n                    query: query\n                @client.off angular.toJson(channel), listener\n\n            emit: (options..., message) ->\n                [path, query] = options\n                channel =\n                    path: path\n                    query: query or {}\n                @client.emit angular.toJson(channel), message, true\n\n            startConsuming: (path) ->\n                socketService.send\n                    cmd: 'startConsuming'\n                    path: path\n\n            stopConsuming: (path) ->\n                socketService.send\n                    cmd: 'stopConsuming'\n                    path: path\n\n            startConsumingAll: (paths) ->\n                if angular.isArray(paths)\n                    socketPaths = paths[...]\n                else if angular.isObject(paths)\n                    socketPaths = Object.keys(paths)\n                else throw new Error('Parameter paths is not an object or an array')\n\n                # filter socket paths that are included in another paths\n                pathsToRemove = []\n                for p, i in socketPaths\n                    r = ///^#{p.replace(/\\*/g, '(\\\\w+|\\\\d+|\\\\*)')}$///\n                    for q, j in socketPaths\n                        if j != i and r.test(q) then pathsToRemove.push(q)\n                for p in pathsToRemove\n                    socketPaths.splice socketPaths.indexOf(p), 1\n\n                promises = []\n                for path in socketPaths\n                    if path not of @trackedPaths\n                        @consuming[path] = true\n                        promises.push @startConsuming(path)\n\n                return $q.all(promises)\n\n            mergePaths: (dest, src) ->\n                for path, queries of src\n                    dest[path] ?= []\n                    for query in queries\n                        if dest[path].filter (e) ->\n                            angular.equals(e, query)\n                        .length == 0\n                            dest[path].push(query)\n","class Collection extends Factory\n    constructor: ($q, $injector, $log, dataUtilsService, tabexService, indexedDBService, SPECIFICATION) ->\n        return class CollectionInstance extends Array\n            constructor: (restPath, query = {}) ->\n                @getRestPath = -> restPath\n                @getQuery = -> query\n                @getSocketPath = -> dataUtilsService.socketPath(restPath)\n                @getType = -> dataUtilsService.type(restPath)\n                @getEndpoint = -> dataUtilsService.endpointPath(restPath)\n                @getSpecification = -> SPECIFICATION[@getType()]\n                Wrapper = $injector.get('Wrapper')\n                @getWrapper = -> Wrapper\n\n                ready = $q.defer()\n                @getReadyDeferred = -> ready\n                @getReadyPromise = -> ready.promise\n\n            subscribe: ->\n                tabexService.on @getSocketPath(), @getQuery(), @listener\n                promise = @getReadyPromise()\n                promise.getArray = => return this\n                return promise\n\n            unsubscribe: ->\n                @forEach (e) -> e?.unsubscribe?()\n                tabexService.off @getSocketPath(), @getQuery(), @listener\n\n            listener: (event) =>\n                if event is tabexService.EVENTS.READY and @length != 0 then return\n                query = angular.copy(@getQuery())\n                delete query.subscribe\n                indexedDBService.get(@getRestPath(), query).then (data) =>\n                    if not angular.isArray(data) then data = [data]\n                    switch event\n                        when tabexService.EVENTS.READY then @readyHandler(data)\n                        when tabexService.EVENTS.UPDATE then @updateHandler(data)\n                        when tabexService.EVENTS.NEW then @newHandler(data)\n                        else $log.error('Unhandled tabex event', event)\n\n            readyHandler: (data) ->\n                @from(data)\n                @getReadyDeferred()?.resolve(@)\n\n            # add new elements and remove old ones\n            newHandler: (data) ->\n                id = @getSpecification().id\n                ids =\n                    new: data.map (e) -> e[id]\n                    old: @map (e) -> e[id]\n\n                # add new\n                data.forEach (e) => if e[id] not in ids.old then @add(e)\n\n                # delete old\n                @forEach (e) => if e[id] not in ids.new then @delete(e)\n\n            updateHandler: (data) ->\n                @newHandler(data)\n\n                id = @getSpecification().id\n                for e in data\n                    @forEach (i) -> if e[id] == i[id] then i.update(e)\n\n            from: (data) ->\n                # add items one by one\n                @add(i) for i in data\n\n            add: (element) ->\n                Wrapper = @getWrapper()\n                instance = new Wrapper(element, @getEndpoint(), @getQuery().subscribe)\n                @push(instance)\n\n            clear: ->\n                @pop() while @length > 0\n\n            delete: (element) ->\n                index = @indexOf(element)\n                if index > -1 then @splice(index, 1)\n","class Wrapper extends Factory\n    constructor: ($log, dataService, dataUtilsService, tabexService, SPECIFICATION) ->\n        return class WrapperInstance\n            constructor: (object, endpoint, @_subscribe) ->\n                if not angular.isString(endpoint)\n                    throw new TypeError(\"Parameter 'endpoint' must be a string, not #{typeof endpoint}\")\n                @_endpoint = endpoint\n\n                # add object fields to the instance\n                @update(object)\n\n                # generate getXXX, and loadXXX functions\n                endpoints = Object.keys(SPECIFICATION)\n                @constructor.generateFunctions(endpoints)\n\n            update: (o) ->\n                angular.merge(@, o)\n\n            get: (args...) ->\n                [root, id, path...] = @_endpoint.split('/')\n                [options..., last] = args\n                if angular.isObject(last)\n                    pathString = path.concat('*', options).join('/')\n                    if @_subscribe? then args[args.length - 1].subscribe ?= @_subscribe\n                else\n                    pathString = path.concat('*', args).join('/')\n                    if @_subscribe? then args.push(subscribe: @_subscribe)\n                if path.length == 0\n                    return dataService.get(@_endpoint, @getId(), args...)\n\n                specification = SPECIFICATION[root]\n                match = specification.paths.filter (p) ->\n                    replaced = p\n                        .replace ///\\w+\\:\\w+///g, '(\\\\*|\\\\w+|\\\\d+)'\n                    ///^#{replaced}$///.test(pathString)\n                .pop()\n                if not match?\n                    parameter = @getId()\n                else\n                    # second last element\n                    for e in match.split('/')[...-1] by -1\n                        if e.indexOf(':') > -1\n                            [fieldType, fieldName] = e.split(':')\n                            parameter = @[fieldName]\n                            break\n\n                dataService.get(@_endpoint, parameter, args...)\n\n            control: (method, params) ->\n                dataService.control(\"#{@_endpoint}/#{@getIdentifier() or @getId()}\", method, params)\n\n            # generate endpoint functions for the class\n            @generateFunctions: (endpoints) ->\n                endpoints.forEach (e) =>\n                    if e == e.toUpperCase() then return\n                    # capitalize endpoint names\n                    E = dataUtilsService.capitalize(e)\n                    # adds getXXX functions to the prototype\n                    @::[\"get#{E}\"] ?= (args...) ->\n                        return @get(e, args...)\n                    # adds loadXXX functions to the prototype\n                    @::[\"load#{E}\"] ?= (args...) ->\n                        p = @get(e, args...)\n                        @[e] = p.getArray()\n                        return p\n\n            getId: ->\n                @[@classId()]\n\n            getIdentifier: ->\n                @[@classIdentifier()]\n\n            classId: ->\n                SPECIFICATION[dataUtilsService.type(@_endpoint)].id\n\n            classIdentifier: ->\n                SPECIFICATION[dataUtilsService.type(@_endpoint)].identifier\n\n            unsubscribe: ->\n                e?.unsubscribe?() for _, e of this\n"],"sourceRoot":"/source/"}